# auto generated from _meta/bibtex.bib
- key: Sculthorpe-14-Century
  cite: |
    N. Sculthorpe, A. Farmer, and A. Gill, “Making a century in hermit,”
    Submitted to the Draft Proceedings of IFL, 2014.
  a_cite: |
    N. Sculthorpe, A. Farmer, and A. Gill, “[Making a century in hermit](/papers/Sculthorpe-14-Century),”
    Submitted to the Draft Proceedings of IFL, 2014.
  year: 2014
  links:
  abstract: |
    A benefit of pure functional programming is that it encourages equational reasoning. 
    However, the Haskell language currently lacks direct tool support for such reasoning. Consequently, 
    reasoning about Haskell programs is either performed manually, or in another language that does
    provide tool support (e.g. Agda). 
    HERMIT is a Haskell-specific toolkit designed to support equational reasoning and 
    user-guided program transformation, and to do so as part of the GHC compilation pipeline.
    This extended abstract presents a detailed case study of HERMIT usage in practice: 
    mechanising Bird’s classic “Making a Century” pearl. We also use the mechanised
    pearl to introduce recent HERMIT developments for supporting for equational reasoning.
  bibtex: |
    @misc{Sculthorpe:14:Century,
      author = {Sculthorpe, Neil and Farmer, Andrew and Gill, Andrew},
      year = {2014},
      title = {Making a Century in HERMIT},
      howpublished = {Submitted to the Draft Proceedings of IFL},
    }

- key: Torrence-14-BetterLife
  cite: |
    B. Torrence, M. Stees, and A. Gill, “Worker/wrapper for a better life,”
    Submitted to the Draft Proceedings of IFL, 2014.
  a_cite: |
    B. Torrence, M. Stees, and A. Gill, “[Worker/wrapper for a better life](/papers/Torrence-14-BetterLife),”
    Submitted to the Draft Proceedings of IFL, 2014.
  year: 2014
  links:
  abstract: |
    In Software Engineering, an implementation, and its model, can fall out of step.
    If we can connect the implementation and model, then development of both artifacts
    can continue, while retaining confidence in the overall design and implementation.
    In this paper, we show it is possible in practice to
    connect together an executable specification of Conway's Game of Life,
    and a number of implementations, using the worker/wrapper transformation.
    In particular, we use the rewrite tool HERMIT to apply post-hoc transformations to
    replace a linked-list based description with other data structures.
    Directed optimizations allow for highly-efficient executable specifications,
    where the model becomes the implementation.
    This work is the first time programmer-directed worker/wrapper
    has been attempted on a whole application,
    rather than simply on individual functions.
    Beyond data representation improvement, we translate our model
    such that we can execute on a CPU/GPU hybrid, by targeting
    the accelerate DSL.
  bibtex: |
    @misc{Torrence:14:BetterLife,
      author = {Torrence, Brad and Stees, Make and Gill, Andrew},
      year = {2014},
      title = {Worker/wrapper for a Better Life},
      howpublished = {Submitted to the Draft Proceedings of IFL},
    }

- key: Gill-14-BlankCanvas
  cite: |
    A. Gill, A. Eskilson, R. Scott, and J. Stanton, “Blank canvas and the
    remote-monad design pattern: A foreign function interface to the
    javascript canvas api,” Submitted to the Draft Proceedings of IFL, 2014.
  a_cite: |
    A. Gill, A. Eskilson, R. Scott, and J. Stanton, “[Blank canvas and the
    remote-monad design pattern: A foreign function interface to the
    javascript canvas api](/papers/Gill-14-BlankCanvas),” Submitted to the Draft Proceedings of IFL, 2014.
  year: 2014
  links:
  abstract: |
    JavaScript is the de-facto assembly language of the internet.
    Browsers offer an array of powerful rendering and event processing services,
    including a simple 2D canvas.
    Blank Canvas is Haskell DSL that provides a Foreign Function Interface
    to the JavaScript canvas API and the JavaScript event API.
    With this capability, Haskell programmers can draw pictures on the browsers,
    and access input from the keyboard and mouse.
    At the University of Kansas, we use the blank-canvas package for teaching Haskell,
    where it provides a more interesting I/O experience than stdio.
    
    We investigate the use of the remote-monad design
    pattern, using Blank Canvas as our driving example. After explaining
    the design pattern, and constructing the basic remote capability,
    we critically assess the feasibility of our straightforward
    approach, and explore improvements.
  bibtex: |
    @misc{Gill:14:BlankCanvas,
      author = {Gill, Andrew and Eskilson, Aleksander and Scott,Ryan and Stanton, James},
      year = {2014},
      title = {Blank Canvas and the remote-monad design pattern: A Foreign Function Interface to the JavaScript Canvas API},
      howpublished = {Submitted to the Draft Proceedings of IFL},
    }

- key: Sculthorpe-14-KURE
  cite: |
    N. Sculthorpe, N. Frisby, and A. Gill, “The <span>K</span>ansas
    <span>U</span>niversity <span>R</span>ewrite <span>E</span>ngine: A
    <span>H</span>askell-embedded strategic programming language with custom
    closed universes,” *Journal of Functional Programming*, 2014.
  a_cite: |
    N. Sculthorpe, N. Frisby, and A. Gill, “[The <span>K</span>ansas
    <span>U</span>niversity <span>R</span>ewrite <span>E</span>ngine: A
    <span>H</span>askell-embedded strategic programming language with custom
    closed universes](/papers/Sculthorpe-14-KURE),” *Journal of Functional Programming*, 2014.
  year: 2014
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Sculthorpe-13-KURE.pdf>
    - <http://www.ittc.ku.edu/csdl/fpg/software/kure.html>
  abstract: |
    When writing transformation systems, a significant
    amount of engineering effort goes into setting up
    the infrastructure needed to direct individual
    transformations to specific targets in the data
    being transformed.  Strategic programming languages
    provide general-purpose infrastructure for this
    task, which the author of a transformation system
    can use for any algebraic data structure.  The
    Kansas University Rewrite Engine (KURE) is a typed
    strategic programming language, implemented as a
    Haskell-embedded domain-specific language. KURE is
    designed to support typed transformations over typed
    data, and the main challenge is how to make such
    transformations compatible with generic traversal
    strategies that should operate over any type.
    Strategic programming in a typed setting has much in
    common with datatype-generic programming.  Compared
    to other approaches to datatype-generic programming,
    the distinguishing feature of KURE's solution is
    that the user can configure the behaviour of
    traversals based on the location of each datum in
    the tree, beyond their behaviour being determined by
    the type of each datum.  This article describes
    KURE's approach to assigning types to generic
    traversals, and the implementation of that approach.
    We also compare KURE, its design choices, and their
    consequences, with other approaches to strategic and
    datatype-generic programming.
  bibtex: |
    @article{Sculthorpe:14:KURE,
      author = {Neil Sculthorpe and Nicolas Frisby and Andy Gill},
      title = {The {K}ansas {U}niversity {R}ewrite {E}ngine: A {H}askell-Embedded Strategic Programming Language with Custom Closed Universes},
      journal = {Journal of Functional Programming},
      publisher = {Cambridge University Press},
      year = {2014},
    }

- key: Gill-14-DSLs-and-Synthesis
  cite: |
    A. Gill, “Domain-specific languages and code synthesis using haskell,”
    *Commun. ACM*, vol. 57, no. 6, pp. 42–49, jun 2014, also appeared in ACM
    Queue, Vol 12(4), April 2014.
  a_cite: |
    A. Gill, “[Domain-specific languages and code synthesis using haskell](/papers/Gill-14-DSLs-and-Synthesis),”
    *Commun. ACM*, vol. 57, no. 6, pp. 42–49, jun 2014, also appeared in ACM
    Queue, Vol 12(4), April 2014.
  year: 2014
  links:
    - <http://doi.acm.org/10.1145/2605205>
  bibtex: |
    @article{Gill:14:DSLs-and-Synthesis,
      author = {Gill, Andy},
      title = {Domain-specific Languages and Code Synthesis Using Haskell},
      journal = {Commun. ACM},
      issue_date = {June 2014},
      volume = {57},
      number = {6},
      month = {jun},
      year = {2014},
      issn = {0001-0782},
      pages = {42--49},
      numpages = {8},
      doi = {10.1145/2605205},
      acmid = {2605205},
      publisher = {ACM},
      address = {New York, NY, USA},
      note = {Also appeared in ACM Queue, Vol 12(4), April 2014},
    }

- key: Bracker-14-Sunroof
  cite: |
    J. Bracker and A. Gill, “Sunroof: A monadic <span>DSL</span> for
    generating <span>J</span>ava<span>S</span>cript,” in *Practical Aspects
    of Declarative Languages*, ser. Lecture Notes in Computer Science,
    M. Flatt and H.-F. Guo, Eds. Springer International Publishing, 2014,
    vol. 8324, pp. 65–80.
  a_cite: |
    J. Bracker and A. Gill, “[Sunroof: A monadic <span>DSL</span> for
    generating <span>J</span>ava<span>S</span>cript](/papers/Bracker-14-Sunroof),” in *Practical Aspects
    of Declarative Languages*, ser. Lecture Notes in Computer Science,
    M. Flatt and H.-F. Guo, Eds. Springer International Publishing, 2014,
    vol. 8324, pp. 65–80.
  year: 2014
  links:
    - <http://dx.doi.org/10.1007/978-3-319-04132-2_5>
  abstract: |
    Sunroof is a Haskell-hosted Domain Specific Language (DSL)
    for generating JavaScript. The central feature of
    Sunroof is a JavaScript monad, which, like the
    Haskell IO-monad, allows access to external
    resources, but specifically JavaScript resources. As
    such, Sunroof is primarily a feature-rich
    foreign-function API to the browser’s JavaScript
    engine, and all the browser-specific functionality,
    including HTML-based rendering, event handling, and
    drawing to the HTML5 canvas element.  
    
    In this paper,
    we give the design and implementation of
    Sunroof. Using monadic reification, we generate
    JavaScript from a deep embedding of the JavaScript
    monad. The Sunroof DSL has the feel of native
    Haskell, with a simple Haskell-based type schema to
    guide the Sunroof programmer. Furthermore, because
    we are generating code, we can offer Haskell-style
    concurrency patterns, such as MVars and Channels. In
    combination with a web-services package, the Sunroof
    DSL offers a robust platform to build interactive
    web applications.
  bibtex: |
    @incollection{Bracker:14:Sunroof,
      year = {2014},
      isbn = {978-3-319-04131-5},
      booktitle = {Practical Aspects of Declarative Languages},
      volume = {8324},
      series = {Lecture Notes in Computer Science},
      editor = {Flatt, Matthew and Guo, Hai-Feng},
      doi = {10.1007/978-3-319-04132-2_5},
      title = {Sunroof: A Monadic {DSL} for Generating {J}ava{S}cript},
      publisher = {Springer International Publishing},
      keywords = {DSLs; JavaScript; Web Technologies; Cloud Computing},
      author = {Bracker, Jan and Gill, Andy},
      pages = {65-80},
    }

- key: Farmer-14-HERMITinStream
  cite: |
    A. Farmer, C. <span>Höner zu Siederdissen</span>, and A. Gill, “The
    <span>HERMIT</span> in the <span>Stream</span>,” in *Proceedings of the
    2014 ACM SIGPLAN Workshop on Partial Evaluation and Program
    Manipulation*, ser. PEPM ’14. ACM, 2014.
  a_cite: |
    A. Farmer, C. <span>Höner zu Siederdissen</span>, and A. Gill, “[The
    <span>HERMIT</span> in the <span>Stream</span>](/papers/Farmer-14-HERMITinStream),” in *Proceedings of the
    2014 ACM SIGPLAN Workshop on Partial Evaluation and Program
    Manipulation*, ser. PEPM ’14. ACM, 2014.
  year: 2014
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Farmer-14-HERMITinStream.pdf>
  abstract: |
    Stream Fusion, a popular deforestation technique in the Haskell community, cannot fuse the concatMap combinator. This is a serious limitation, as concatMap represents computations on nested streams. The original implementation of Stream Fusion used the Glasgow Haskell Compiler’s user-directed rewriting system. A transformation which allows the compiler to fuse many uses of concatMap has previously been proposed, but never implemented, because the host rewrite system was not expressive enough to implement the proposed transformation. In this paper, we develop a custom optimization plugin which implements the proposed concatMap transformation, and study the effectiveness of the transformation in practice. We also provide a new translation scheme for list comprehensions which enables them to be optimized. Within this framework, we extend the transformation to monadic streams. Code featuring uses of concatMap experiences significant speedup when compiled with this optimization. This allows Stream Fusion to outperform its rival, foldr/build, on many list computations, and enables performance-sensitive code to be expressed at a higher level of abstraction.
  bibtex: |
    @inproceedings{Farmer:14:HERMITinStream,
      author = {Andrew Farmer and Christian {H\"{o}ner zu Siederdissen} and Andy Gill},
      title = {The {HERMIT} in the {Stream}},
      booktitle = {Proceedings of the 2014 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
      series = {PEPM '14},
      publisher = {ACM},
      location = {San Diego, California, USA},
      year = {2014},
    }

- key: Adams-14-OSIE
  cite: |
    M. D. Adams, A. Farmer, and J. P. <span>Magalhães</span>, “Optimizing
    <span>SYB</span> <span>Is</span> <span>Easy</span>!” in *Proceedings of
    the 2014 ACM SIGPLAN Workshop on Partial Evaluation and Program
    Manipulation*, ser. PEPM ’14. ACM, 2014.
  a_cite: |
    M. D. Adams, A. Farmer, and J. P. <span>Magalhães</span>, “[Optimizing
    <span>SYB</span> <span>Is</span> <span>Easy</span>!](/papers/Adams-14-OSIE)” in *Proceedings of
    the 2014 ACM SIGPLAN Workshop on Partial Evaluation and Program
    Manipulation*, ser. PEPM ’14. ACM, 2014.
  year: 2014
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Adams-14-OSIE.pdf>
  abstract: |
    The most widely used generic-programming system in the Haskell community, Scrap Your Boilerplate (SYB), also happens to be one of the slowest. Generic traversals in SYB are about an order of magnitude slower than equivalent handwritten, non-generic traversals. Thus while SYB allows the concise expression of many traversals, its use incurs a significant runtime cost. Existing techniques for optimizing other generic-programming systems are not able to eliminate this overhead. 
    
    This paper presents an optimization that completely eliminates this cost. The optimization takes advantage of domain-specific knowledge about the structure of SYB and in so doing can optimize SYB-style traversals to be as fast as handwritten, non-generic code. 
    
    This paper presents both the formal structure of the optimization and the results of benchmarking the optimized SYB code against both unoptimized SYB code and handwritten, non-generic code. In these benchmarks, the optimized SYB code matches the performance of handwritten code even when the unoptimized SYB code is an order of magnitude or more slower.
  bibtex: |
    @inproceedings{Adams:14:OSIE,
      author = {Michael D. Adams and Andrew Farmer and Jos\'{e} Pedro {Magalh\~{a}es}},
      title = {Optimizing {SYB} {Is} {Easy}!},
      booktitle = {Proceedings of the 2014 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
      series = {PEPM '14},
      publisher = {ACM},
      location = {San Diego, California, USA},
      year = {2014},
    }

- key: Sculthorpe-13-ConstrainedMonad
  cite: |
    N. Sculthorpe, J. Bracker, G. Giorgidze, and A. Gill, “The
    constrained-monad problem,” in *In Proceedings of the 18th ACM SIGPLAN
    International Conference on Functional Programming*. ACM, 2013, pp.
    287–298.
  a_cite: |
    N. Sculthorpe, J. Bracker, G. Giorgidze, and A. Gill, “[The
    constrained-monad problem](/papers/Sculthorpe-13-ConstrainedMonad),” in *In Proceedings of the 18th ACM SIGPLAN
    International Conference on Functional Programming*. ACM, 2013, pp.
    287–298.
  year: 2013
  links:
    - <http://dl.acm.org/citation.cfm?doid=2500365.2500602>
    - <http://www.ittc.ku.edu/csdl/fpg/files/ Sculthorpe-13-ConstrainedMonad.pdf>
  abstract: |
    In Haskell, there are many data types that would form
    monads were it not for the presence of type-class
    constraints on the operations on that data type.
    This is a frustrating problem in practice, because
    there is a considerable amount of support and
    infrastructure for monads that these data types
    cannot use.  Using several examples, we show that a
    monadic computation can be restructured into a
    normal form such that the standard monad class
    can be used.  The technique is not specific
    to monads, and we show how it can also be applied to
    other structures, such as applicative functors.  One
    significant use case for this technique is domain-specific
    languages, where it is often desirable to
    compile a deep embedding of a computation to some
    other language, which requires restricting the types
    that can appear in that computation.
  bibtex: |
    @inproceedings{Sculthorpe:13:ConstrainedMonad,
      author = {Neil Sculthorpe and Jan Bracker and George Giorgidze and Andy Gill},
      title = {The Constrained-Monad Problem},
      booktitle = {In Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming},
      publisher = {ACM},
      location = {Boston, Massachusetts},
      pages = {287--298},
      year = {2013},
    }

- key: Sculthorpe-14-WorkIt
  cite: |
    N. Sculthorpe and G. Hutton, “Work it, wrap it, fix it, fold it,”
    *Journal of Functional Programming*, vol. 24, no. 1, pp. 113–127, 2014.
  a_cite: |
    N. Sculthorpe and G. Hutton, “[Work it, wrap it, fix it, fold it](/papers/Sculthorpe-14-WorkIt),”
    *Journal of Functional Programming*, vol. 24, no. 1, pp. 113–127, 2014.
  year: 2014
  links:
    - <http://dx.doi.org/10.1017/S0956796814000045>
  abstract: |
    The worker/wrapper transformation is a general-purpose technique
    for refactoring recursive programs to improve their performance.
    The two previous approaches to formalising the technique were
    based upon different recursion operators and different correctness
    conditions.  In this article we show how these two approaches can
    be generalised in a uniform manner by combining their correctness
    conditions, how the theory can be extended with new conditions
    that are necessary (in addition to sufficient) to ensure the correctness
    of the worker/wrapper technique, and explore the benefits that result.
    All the proofs have been mechanically verified using the Agda system.
  bibtex: |
    @article{Sculthorpe:14:WorkIt,
      author = {Neil Sculthorpe and Graham Hutton},
      title = {Work It, Wrap It, Fix It, Fold It},
      journal = {Journal of Functional Programming},
      pages = {113--127},
      volume = {24},
      number = {1},
      publisher = {Cambridge University Press},
      year = {2014},
    }

- key: Gill-13-TypesKansasLava
  cite: |
    A. Gill, T. Bull, A. Farmer, G. Kimmell, and E. Komp, “Types and
    associated type families for hardware simulation and synthesis: The
    internals and externals of <span>K</span>ansas <span>L</span>ava,”
    *Higher-Order and Symbolic Computation*, pp. 1–20, 2013.
  a_cite: |
    A. Gill, T. Bull, A. Farmer, G. Kimmell, and E. Komp, “[Types and
    associated type families for hardware simulation and synthesis: The
    internals and externals of <span>K</span>ansas <span>L</span>ava](/papers/Gill-13-TypesKansasLava),”
    *Higher-Order and Symbolic Computation*, pp. 1–20, 2013.
  year: 2013
  links:
    - <http://dx.doi.org/10.1007/s10990-013-9098-7>
  abstract: |
    In this article
    we overview the design and implementation of the second generation
    of Kansas Lava.
    Driven by the needs and experiences
    of implementing telemetry decoders and other circuits,
    we have made a number of improvements to both the external API
    and the internal representations used.
    We have retained our dual shallow/deep
    representation of signals in general, but now have a number of externally visible
    abstractions for combinatorial and sequential circuits, and enabled signals.
    We introduce these abstractions, as well as our abstractions for
    reading and writing memory.
    Internally, we found the need to represent unknown values inside our circuits,
    so we made aggressive use of associated type families to lift our values in a principled
    and regular way. We discuss this design decision, how it unfortunately
    complicates the internals of Kansas Lava, and how
    we mitigate this complexity.
    Finally, when connecting Kansas Lava to the real world,
    the standardized idiom of using named input and output ports
    is provided by Kansas Lava using a new monad, called \verb|Fabric|.
    We present the design of this Fabric monad, and
    illustrate its use in a small but complete example.
  bibtex: |
    @article{Gill:13:TypesKansasLava,
      issn = {1388-3690},
      journal = {Higher-Order and Symbolic Computation},
      doi = {10.1007/s10990-013-9098-7},
      publisher = {Springer US},
      keywords = {Domain specific languages; Hardware; Synthesis; Types},
      pages = {1-20},
      title = {Types and Associated Type Families for Hardware Simulation and Synthesis:
              The Internals and Externals of {K}ansas {L}ava},
      author = {Andy Gill and Tristan Bull and Andrew Farmer and Garrin Kimmell and Ed Komp},
      year = {2013},
    }

- key: Sculthorpe-13-HERMITinTree
  cite: |
    N. Sculthorpe, A. Farmer, and A. Gill, “The <span>HERMIT</span> in the
    tree: Mechanizing program transformations in the <span>GHC</span> core
    language,” in *Proceedings of the 24th Symposium on Implementation and
    Application of Functional Languages*, ser. Lecture Notes in Computer
    Science, vol. 8241, 2013, pp. 86–103.
  a_cite: |
    N. Sculthorpe, A. Farmer, and A. Gill, “[The <span>HERMIT</span> in the
    tree: Mechanizing program transformations in the <span>GHC</span> core
    language](/papers/Sculthorpe-13-HERMITinTree),” in *Proceedings of the 24th Symposium on Implementation and
    Application of Functional Languages*, ser. Lecture Notes in Computer
    Science, vol. 8241, 2013, pp. 86–103.
  year: 2013
  links:
    - <http://dx.doi.org/10.1007/978-3-642-41582-1_6>
    - <http://www.ittc.ku.edu/csdl/fpg/files/Sculthorpe-13-HERMITinTree-extended.pdf>
  abstract: |
    This paper describes our experience using the HERMIT toolkit to apply
    well-known transformations to the internal core language of the
    Glasgow Haskell Compiler.  HERMIT provides several mechanisms to
    support writing general-purpose transformations: a domain-specific
    language for strategic programming specialized to GHC's core
    language, a library of primitive rewrites, and a shell-style--based
    scripting language for interactive and batch usage.
    
    There are many program transformation techniques that have been
    described in the literature but have not been mechanized and made
    available inside GHC --- either because they are too specialized to
    include in a general-purpose compiler, or because the developers'
    interest is in theory rather than implementation. The mechanization
    process can often reveal pragmatic obstacles that are glossed over in
    pen-and-paper proofs; understanding and removing these obstacles is our
    concern. Using HERMIT, we implement eleven examples of three program
    transformations, report on our experience, and describe improvements
    made in the process.
  bibtex: |
    @inproceedings{Sculthorpe:13:HERMITinTree,
      author = {Neil Sculthorpe and Andrew Farmer and Andy Gill},
      title = {The {HERMIT} in the Tree: Mechanizing Program Transformations in the {GHC} Core Language},
      booktitle = {Proceedings of the 24th Symposium on Implementation and Application of Functional Languages},
      location = {Oxford, England},
      series = {Lecture Notes in Computer Science},
      pages = {86--103},
      volume = {8241},
      year = {2013},
    }

- key: Farmer-12-HERMITinMachine
  cite: |
    A. Farmer, A. Gill, E. Komp, and N. Sculthorpe, “The <span>HERMIT</span>
    in the machine: A plugin for the interactive transformation of
    <span>GHC</span> core language programs,” in *Proceedings of the ACM
    SIGPLAN Haskell Symposium*, ser. Haskell ’12. ACM, 2012, pp. 1–12.
  a_cite: |
    A. Farmer, A. Gill, E. Komp, and N. Sculthorpe, “[The <span>HERMIT</span>
    in the machine: A plugin for the interactive transformation of
    <span>GHC</span> core language programs](/papers/Farmer-12-HERMITinMachine),” in *Proceedings of the ACM
    SIGPLAN Haskell Symposium*, ser. Haskell ’12. ACM, 2012, pp. 1–12.
  year: 2012
  links:
    - <http://doi.acm.org/10.1145/2364506.2364508>
    - <http://www.ittc.ku.edu/csdl/fpg/files/Farmer-12-HERMITinMachine.pdf>
  abstract: |
    The importance of reasoning about and refactoring programs
    is a central tenet of functional programming.
    Yet our compilers and development toolchains
    only provide rudimentary support for these tasks.
    This paper introduces
    a programmatic and compiler-centric interface
    that facilitates refactoring and equational reasoning.
    To develop our ideas, we have implemented HERMIT, a toolkit enabling
    informal but systematic transformation of Haskell
    programs from \emph{inside} the Glasgow Haskell Compiler{\textquoteright}s
    optimization pipeline.
    With HERMIT, users can experiment with optimizations
    and equational reasoning, while the
    tedious heavy lifting of performing the actual transformations
    is done for them.
    
    HERMIT provides a transformation API that can be
    used to build higher-level rewrite tools.
    One use-case is
    prototyping new optimizations as clients of this API
    before being committed to the GHC toolchain.
    We describe a HERMIT application---a
    read-eval-print shell for performing transformations using HERMIT.
    We also demonstrate using this shell to prototype an optimization
    on a specific example, and report our initial experiences and
    remaining challenges.
  bibtex: |
    @inproceedings{Farmer:12:HERMITinMachine,
      author = {Andrew Farmer and Andy Gill and Ed Komp and Neil Sculthorpe},
      title = {The {HERMIT} in the Machine: A Plugin for the Interactive Transformation of {GHC} Core Language Programs},
      booktitle = {Proceedings of the ACM SIGPLAN Haskell Symposium},
      series = {Haskell '12},
      year = {2012},
      isbn = {978-1-4503-1574-6},
      location = {Copenhagen, Denmark},
      pages = {1--12},
      doi = {10.1145/2364506.2364508},
      acmid = {2364508},
      publisher = {ACM},
      keywords = {{DSL}s, equational reasoning, {GHC}, optimization, strategic programming},
    }

- key: Farmer-12-WebDSLs
  cite: |
    A. Farmer and A. Gill, “Haskell <span>DSL</span>s for interactive web
    services,” in *1st International Workshop on Cross-model Language Design
    and Implementation*, Sep 2012.
  a_cite: |
    A. Farmer and A. Gill, “[Haskell <span>DSL</span>s for interactive web
    services](/papers/Farmer-12-WebDSLs),” in *1st International Workshop on Cross-model Language Design
    and Implementation*, Sep 2012.
  year: 2012
  links:
  abstract: |
    Robust cross-platform GUI-based applications are challenging to write in Haskell,
    not because providing hooks into existing GUI frameworks is hard,
    but because these hooks are both platform dependent and prone to rapid bit-rot.
    Browser-based user interfaces implemented using
    Javascript and HTML5 offer some relief from this situation,
    providing a standardized cross-platform API.
    However, Javascript is a client-side scripting language, and
    a traditional shallow, foreign-function-call style Haskell
    interface to the client does not scale well because calling a
    Javascript command involves sending the command, and optionally waiting for a response, over a network.
    Instead, we build a deep embedding of Javascript commands inside a Javascript monad.
    Along with supporting web-based infrastructure,
    we deliver entire program fragments
    to our web-based applications.
    Using our monad, the Haskell programmer can choose the
    granularity of interaction, with the option of
    having reactive interfaces that are completely
    handled by the client.
  bibtex: |
    @inproceedings{Farmer:12:WebDSLs,
      author = {Andrew Farmer and Andy Gill},
      title = {Haskell {DSL}s for Interactive Web Services},
      booktitle = {1st International Workshop on Cross-model Language Design and Implementation},
      location = {Copenhagen, Denmark},
      year = {2012},
      month = {Sep},
    }

- key: Frisby-12-AlmostHomomorphicFunctions
  cite: |
    N. Frisby, A. Gill, and P. Alexander, “A pattern for almost homomorphic
    functions,” in *ACM SIGPLAN Workshop on Generic Programming*, Sep 2012.
  a_cite: |
    N. Frisby, A. Gill, and P. Alexander, “[A pattern for almost homomorphic
    functions](/papers/Frisby-12-AlmostHomomorphicFunctions),” in *ACM SIGPLAN Workshop on Generic Programming*, Sep 2012.
  year: 2012
  links:
  abstract: |
    Strong typing presents the programmer with a trade-off between correctness and
    code complexity: more exact types prevent errors but less exact types enable
    reuse.
    Current functional programming practice prefers general types over exact types
    in large programs like compilers because of the reuse. Exact typing in these
    programs would require numerous similar data types and conversions between
    them.
    We factor out a pattern in such conversions as a reusable Haskell function. We
    extend existing generic programming techniques to define it and to use it
    without introducing undue obfuscation.
    Our reusable function eliminates the boilerplate for conversions between the
    numerous exact types. It therefore delivers the benefits of exact types and
    simulates the reusability of general types with lightweight generic
    programming.
    We demonstrate our function by using it to define a lambda-lifting function
    with an exact range type that has no constructor for lambdas.
  bibtex: |
    @inproceedings{Frisby:12:AlmostHomomorphicFunctions,
      author = {Nicolas Frisby and Andy Gill and Perry Alexander},
      title = {A Pattern for Almost Homomorphic Functions},
      booktitle = {ACM SIGPLAN Workshop on Generic Programming},
      location = {Copenhagen, Denmark},
      year = {2012},
      month = {Sep},
    }

- key: Gill-12-PatchLogic
  cite: |
    A. Gill and B. Neuenschwander, “Handshaking in <span>K</span>ansas
    <span>L</span>ava using patch logic,” in *Practical Aspects of
    Declarative Languages*, ser. LNCS, vol. 7149. Springer-Verlag, January
    2012.
  a_cite: |
    A. Gill and B. Neuenschwander, “[Handshaking in <span>K</span>ansas
    <span>L</span>ava using patch logic](/papers/Gill-12-PatchLogic),” in *Practical Aspects of
    Declarative Languages*, ser. LNCS, vol. 7149. Springer-Verlag, January
    2012.
  year: 2012
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-12-PatchLogic.pdf>
  abstract: |
    Designing hardware is like writing music for an
    orchestra - lots of pieces have to come together at
    the correct time for everything to work. In systems
    design, there is a confusing array of standards for
    allowing cooperating components, and little
    type-level support in traditional design
    methodologies for helping connect components with
    pre-arranged protocols. In this paper, we explore
    bringing protocol-level types to communicating
    processes. Inside our hardware description language
    Kansas Lava we introduce the notation of a patch,
    which is a communicating component with
    well-understood protocols. We build a theory round
    the notion of patches, which we call patch logic,
    and then use the patch abstraction to build a small
    driver for an FPGA board. 
  bibtex: |
    @inproceedings{Gill:12:PatchLogic,
      title = {Handshaking in {K}ansas {L}ava using Patch Logic},
      author = {Andy Gill and Bowe Neuenschwander},
      booktitle = {Practical Aspects of Declarative Languages},
      publisher = {Springer-Verlag},
      series = {LNCS},
      volume = {7149},
      location = {Philadelphia, PA},
      year = {2012},
      month = {January},
    }

- key: IFL11
  cite: |
    A. Gill and J. Hage, Eds., *Implementation and Application of Functional
    Languages*. Springer, LNCS 7257, October 2011.
  a_cite: |
    A. Gill and J. Hage, Eds., *Implementation and Application of Functional
    Languages*. Springer, LNCS 7257, October 2011.
  year: 2011
  links:
  bibtex: |
    @proceedings{IFL11,
      title = {Implementation and Application of Functional Languages},
      editor = {Andy Gill and Jurriaan Hage},
      publisher = {Springer, LNCS 7257},
      year = {2011},
      month = {October},
    }

- key: Gill-11-Declarative
  cite: |
    A. Gill, “Declarative <span>FPGA</span> circuit synthesis using
    <span>K</span>ansas <span>L</span>ava,” in *The International Conference
    on Engineering of Reconfigurable Systems and Algorithms*, July 2011.
  a_cite: |
    A. Gill, “[Declarative <span>FPGA</span> circuit synthesis using
    <span>K</span>ansas <span>L</span>ava](/papers/Gill-11-Declarative),” in *The International Conference
    on Engineering of Reconfigurable Systems and Algorithms*, July 2011.
  year: 2011
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-11-Declarative.pdf>
  abstract: |
    Designing and debugging hardware components is
    challenging, especially when performance
    requirements demands a complex orchestra of
    cooperating and highly synchronized computation
    engines. New language-based solutions to this problem
    have the potential to revolutionize how we think
    about and build circuits. In this paper, we describe
    our language- based approach to semi-formal
    co-design. Using examples, we will show how
    generative techniques, high-level interfaces, and
    refinement techniques like the worker/wrapper
    transformation can be used to take descriptions of
    specialized computation, and generate efficient
    circuits. Kansas Lava, our high-level hardware
    description language built on top of the functional
    language Haskell, acts as a bridge between these
    computational descriptions and synthesizable
    VHDL. Central to the whole approach is the use of
    Haskell types to express communication and timing
    choices between computational components. Design
    choices and engineering compromises during co-design
    become type-centric refinements, encouraging
    architectural exploration. 
  bibtex: |
    @inproceedings{Gill:11:Declarative,
      title = {Declarative {FPGA} Circuit Synthesis using {K}ansas {L}ava},
      booktitle = {The International Conference on Engineering of Reconfigurable Systems and Algorithms},
      year = {2011},
      month = {July},
      location = {Las Vegas, Nevada, USA},
      author = {Andy Gill},
    }

- key: Gill-11-DerivingLDPC
  cite: |
    A. Gill and A. Farmer, “Deriving an efficient <span>FPGA</span>
    implementation of a low density parity check forward error corrector,”
    in *Proceedings of the 16th ACM SIGPLAN international conference on
    Functional programming*, ser. ICFP ’11. ACM, Sep 2011, pp. 209–220.
  a_cite: |
    A. Gill and A. Farmer, “[Deriving an efficient <span>FPGA</span>
    implementation of a low density parity check forward error corrector](/papers/Gill-11-DerivingLDPC),”
    in *Proceedings of the 16th ACM SIGPLAN international conference on
    Functional programming*, ser. ICFP ’11. ACM, Sep 2011, pp. 209–220.
  year: 2011
  links:
    - <http://doi.acm.org/10.1145/2034773.2034804>
  abstract: |
    Creating correct hardware is hard. Though there is much
    talk of using formal and semi-formal methods to
    develop designs and implementations, in practice
    most implementations are written without the support
    of any formal or semi-formal methodology. Having
    such a methodology brings many benefits, including
    improved likelihood of a correct implementation,
    lowering the cost of design exploration and lowering
    the cost of certification. In this paper, we
    introduce a semi formal methodology for connecting
    executable specifications written in the functional
    language Haskell to efficient VHDL
    implementations. The connection is performed by
    manual edits, using semi-formal equational reasoning
    facilitated by the worker/wrapper transformation,
    and directed using commutable functors. We explain
    our methodology on a full-scale example, an
    efficient Low-Density Parity Check forward error
    correcting code, which has been implemented on a
    Virtex-5 FPGA.
  bibtex: |
    @inproceedings{Gill:11:DerivingLDPC,
      author = {Gill, Andy and Farmer, Andrew},
      title = {Deriving an Efficient {FPGA} Implementation of a Low Density Parity Check Forward Error Corrector},
      booktitle = {Proceedings of the 16th ACM SIGPLAN international conference on Functional programming},
      series = {ICFP '11},
      year = {2011},
      isbn = {978-1-4503-0865-6},
      location = {Tokyo, Japan},
      pages = {209--220},
      numpages = {12},
      doi = {10.1145/2034773.2034804},
      acmid = {2034804},
      publisher = {ACM},
      keywords = {dsl, error correction, lava, ldpc},
      month = {Sep},
      location = {Tokyo, Japan},
    }

- key: Gill-11-GeneratingLDPC
  cite: |
    A. Gill, T. Bull, D. DePardo, A. Farmer, E. Komp, and E. Perrins, “Using
    functional programming to generate an <span>LDPC</span> forward error
    corrector,” in *Proceedings of the IEEE 19th Annual International
    Symposium on Field-Programmable Custom Computing Machines*, ser. FCCM
    ’11. IEEE Computer Society, May 2011, pp. 133–140.
  a_cite: |
    A. Gill, T. Bull, D. DePardo, A. Farmer, E. Komp, and E. Perrins, “[Using
    functional programming to generate an <span>LDPC</span> forward error
    corrector](/papers/Gill-11-GeneratingLDPC),” in *Proceedings of the IEEE 19th Annual International
    Symposium on Field-Programmable Custom Computing Machines*, ser. FCCM
    ’11. IEEE Computer Society, May 2011, pp. 133–140.
  year: 2011
  links:
    - <http://dx.doi.org/10.1109/FCCM.2011.31>
  bibtex: |
    @inproceedings{Gill:11:GeneratingLDPC,
      author = {Gill, Andy and Bull, Tristan and DePardo, Dan and Farmer, Andrew and Komp, Ed and Perrins, Erik},
      title = {Using Functional Programming to Generate an {LDPC} Forward Error Corrector},
      booktitle = {Proceedings of the IEEE 19th Annual International Symposium on Field-Programmable Custom Computing Machines},
      series = {FCCM '11},
      year = {2011},
      isbn = {978-0-7695-4301-7},
      pages = {133--140},
      numpages = {8},
      doi = {10.1109/FCCM.2011.31},
      acmid = {1990171},
      publisher = {IEEE Computer Society},
      month = {May},
      location = {Salt Lake City, UT, USA},
    }

- key: Bull-11-FECandFP
  cite: |
    T. Bull, “Forward error correction and functional programming,” Master’s
    thesis, The University of Kansas, 2011.
  a_cite: |
    T. Bull, “[Forward error correction and functional programming](/papers/Bull-11-FECandFP),” Master’s
    thesis, The University of Kansas, 2011.
  year: 2011
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Bull-11-FECandFP.pdf>
  abstract: |
    This thesis contains a collection of work I have
    performed while working on Dr. Erik Perrins’
    Efficient Hardware Implementation of Iterative FEC
    Decoders project. The following topics and my
    contributions to those topics are included in this
    thesis. The first topic is a Viterbi decoder
    implemented in the Haskell programming
    language. Next, I will briefly introduce Kansas
    Lava, a Haskell DSL developed by my advisor,
    Dr. Andy Gill, and other students and staff. The
    goal of Kansas Lava is to generate efficient
    synthesizable VHDL for complex circuits. I will
    discuss one such circuit, a large-scale LDPC decoder
    implemented in Kansas Lava that has been synthesized
    and tested on FPGA hardware. After discussing the
    synthesis and simulation results of the decoder
    circuit, I will discuss a memory interface that was
    developed for use in our HFEC system. Finally, I tie
    these individual projects together in a discussion
    on the benefits of functional programming in
    hardware design.
  bibtex: |
    @mastersthesis{Bull:11:FECandFP,
      author = {Tristan Bull},
      title = {Forward Error Correction and Functional Programming},
      school = {The University of Kansas},
      year = {2011},
    }

- key: Gill-11-CatchingSat
  cite: |
    A. Gill and G. Kimmell, “Capturing functions and catching satellites,”
    Tech. Rep., January 2011, iTTC Technical Report
    ITTC-FY2011-TR-29952011-1.
  a_cite: |
    A. Gill and G. Kimmell, “[Capturing functions and catching satellites](/papers/Gill-11-CatchingSat),”
    Tech. Rep., January 2011, iTTC Technical Report
    ITTC-FY2011-TR-29952011-1.
  year: 2011
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-11-CatchingSat.pdf>
  abstract: |
    The 2009 ICFP programming contest problem required contestants to control
    virtual satellites that obey basic physical laws.  The orbital physics
    behavior of the system was simulated via a binary provided to contestants
    which ran on top of a simple virtual machine.  Contestants were required to
    implement the virtual machine along with a controller program to manipulate
    the satellite{\textquoteright}s behavior. In this paper, we describe the modeling of the
    simulation environment, with a focus on the compilation and testing
    infrastructure for the generated binaries for this virtual machine. This
    infrastructure makes novel use of an implementation of a deeply embedded
    Domain Specific Language (DSL) within Haskell.  In particular, with use of
    IO-based observable sharing, it was straightforward for a function to be both
    an executable specification as well as a portable implementation,
    and because of this the rendered binary was found to be robust and reliable.
  bibtex: |
    @techreport{Gill:11:CatchingSat,
      title = {Capturing Functions and Catching Satellites},
      note = {ITTC Technical Report ITTC-FY2011-TR-29952011-1},
      year = {2011},
      month = {January},
      author = {Andy Gill and Garrin Kimmell},
    }

- key: Hutton-10-F5
  cite: |
    G. Hutton, M. Jaskelioff, and A. Gill, “Factorising folds for faster
    functions,” *Journal of Functional Programming*, vol. 20, no. 3-4, pp.
    353–373, 2010.
  a_cite: |
    G. Hutton, M. Jaskelioff, and A. Gill, “[Factorising folds for faster
    functions](/papers/Hutton-10-F5),” *Journal of Functional Programming*, vol. 20, no. 3-4, pp.
    353–373, 2010.
  year: 2010
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Hutton-10-F5.pdf>
    - <http://www.ittc.ku.edu/csdl/fpg/files/Hutton-10-F5-extended.pdf>
  abstract: |
    The worker/wrapper transformation is a general technique for improving the performance of
    recursive programs by changing their types. The previous formalisation (Gill & Hutton, 2009) was
    based upon a simple fixed point semantics of recursion. In this article we develop a more structured
    approach, based upon initial algebra semantics. In particular, we show how the worker/wrapper
    transformation can be applied to programs defined using the structured pattern of recursion captured
    by fold operators, and illustrate our new technique with a number of examples.
  bibtex: |
    @article{Hutton:10:F5,
      author = {Graham Hutton and Mauro Jaskelioff and Andy Gill},
      title = {Factorising Folds for Faster Functions},
      journal = {Journal of Functional Programming},
      publisher = {Cambridge University Press},
      volume = {20},
      number = {3-4},
      pages = {353--373},
      year = {2010},
    }

- key: Matlage-10-BeginningMiddleEnd
  cite: |
    K. Matlage and A. Gill, “Every animation should have a beginning, a
    middle, and an end,” in *Post-Proceedings of Trends in Functional
    Programming*, ser. LNCS, vol. 6546. Springer-Verlag, May 2010.
  a_cite: |
    K. Matlage and A. Gill, “[Every animation should have a beginning, a
    middle, and an end](/papers/Matlage-10-BeginningMiddleEnd),” in *Post-Proceedings of Trends in Functional
    Programming*, ser. LNCS, vol. 6546. Springer-Verlag, May 2010.
  year: 2010
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Matlage-10-BeginningMiddleEnd.pdf>
  abstract: |
    Animations are sequences of still images chained
    together to tell a story. Every story should have a
    beginning, a middle, and an end. We argue that this
    advice leads to a simple and useful idiom for
    creating an animation Domain Specific Language
    (DSL). We introduce our animation DSL, and show how
    it captures the concept of beginning, middle, and
    end inside a Haskell applicative functor we call
    Active. We have an implementation of our DSL inside
    the image generation accelerator, ChalkBoard, and we
    use our DSL on an extended example, animating a
    visual demonstration of the Pythagorean Theorem.
  bibtex: |
    @inproceedings{Matlage:10:BeginningMiddleEnd,
      title = {Every Animation Should Have a Beginning, a Middle, and an End},
      author = {Kevin Matlage and Andy Gill},
      booktitle = {Post-Proceedings of Trends in Functional Programming},
      month = {May},
      year = {2010},
      publisher = {Springer-Verlag},
      series = {LNCS},
      volume = {6546},
    }

- key: Gill-10-TypesKansasLava
  cite: |
    A. Gill, T. Bull, A. Farmer, G. Kimmell, and E. Komp, “Types and type
    families for hardware simulation and synthesis: The internals and
    externals of <span>K</span>ansas <span>L</span>ava,” in
    *Post-Proceedings of Trends in Functional Programming*, ser. LNCS, vol.
    6546. Springer-Verlag, May 2010.
  a_cite: |
    A. Gill, T. Bull, A. Farmer, G. Kimmell, and E. Komp, “[Types and type
    families for hardware simulation and synthesis: The internals and
    externals of <span>K</span>ansas <span>L</span>ava](/papers/Gill-10-TypesKansasLava),” in
    *Post-Proceedings of Trends in Functional Programming*, ser. LNCS, vol.
    6546. Springer-Verlag, May 2010.
  year: 2010
  links:
  abstract: |
    In this paper,
    
    we overview the design and implementation of our latest
    version of Kansas Lava. Driven by needs and experiences
    of implementing telemetry circuits,
    we have made a number of recent improvements to both the external API
    and the internal representations used.
    We have retained our dual shallow/deep
    representation of signals in general, but now have a number of externally visible
    abstractions for combinatorial, sequential, and enabled signals.
    We introduce these abstractions, as well as our new abstractions for
    memory and memory updates.
    Internally, we found the need to represent unknown values inside our circuits,
    so we made aggressive use of type families to lift our values in a principled
    and regular way. We discuss this design decision, how it unfortunately
    complicates the internals of Kansas Lava, and how
    we mitigate this complexity.
  bibtex: |
    @inproceedings{Gill:10:TypesKansasLava,
      title = {Types and Type Families for Hardware Simulation and Synthesis: The Internals and Externals of {K}ansas {L}ava},
      author = {Andy Gill and Tristan Bull and Andrew Farmer and Garrin Kimmell and Ed Komp},
      booktitle = {Post-Proceedings of Trends in Functional Programming},
      month = {May},
      year = {2010},
      publisher = {Springer-Verlag},
      series = {LNCS},
      volume = {6546},
    }

- key: Farmer-10-WhatsTheMatter
  cite: |
    A. Farmer, G. Kimmell, and A. Gill, “What’s the matter with
    <span>K</span>ansas <span>L</span>ava?” in *Post-Proceedings of Trends
    in Functional Programming*. Springer-Verlag, LNCS 6546, May 2010.
  a_cite: |
    A. Farmer, G. Kimmell, and A. Gill, “[What’s the matter with
    <span>K</span>ansas <span>L</span>ava?](/papers/Farmer-10-WhatsTheMatter)” in *Post-Proceedings of Trends
    in Functional Programming*. Springer-Verlag, LNCS 6546, May 2010.
  year: 2010
  links:
  abstract: |
    Kansas Lava is a functional hardware description language implemented
    in Haskell. In the course of attempting to generate ever larger circuits,
    we have found the need to effectively test and debug the internals of
    Kansas Lava. This includes confirming both the simulated behavior of the
    circuit and its hardware realization via generated VHDL. In
    this paper we share our approach to this problem, and discuss
    the results of these efforts.
  bibtex: |
    @inproceedings{Farmer:10:WhatsTheMatter,
      title = {What's the matter with {K}ansas {L}ava?},
      author = {Andrew Farmer and Garrin Kimmell and Andy Gill},
      booktitle = {Post-Proceedings of Trends in Functional Programming},
      month = {May},
      publisher = {Springer-Verlag, LNCS 6546},
      year = {2010},
    }

- key: Gill-10-ImprovingVideo
  cite: |
    A. Gill, G. Kimmell, and K. Matlage, “Improving the presentation of
    technical material in video talks using post production,” in *2010
    Midwest Section Conference of the American Society for Engineering
    Education*, September 2010.
  a_cite: |
    A. Gill, G. Kimmell, and K. Matlage, “[Improving the presentation of
    technical material in video talks using post production](/papers/Gill-10-ImprovingVideo),” in *2010
    Midwest Section Conference of the American Society for Engineering
    Education*, September 2010.
  year: 2010
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-10-ImprovingVideo.pdf>
  abstract: |
    In this paper, we present our experiences using our image processing toolkit
    ChalkBoard and other video processing tools to post-process a pre-recorded
    conference talk. With inexpensive video cameras, video services like youtube.com
    and vimeo.com, and widely available and inexpensive video editing software, we
    expect this new media to be increasingly used as a mechanism to both promote
    research agendas and deliver technical content. In order to explore the use of
    such media in more detail, the Functional Programming group at KU recorded a
    technical talk and experimented with various post-processing tricks to enhance
    the value of the talk. Specifically, we fixed a common lensing issue in software,
    added small animations and pictures which matched the gestures of the actors,
    improved the visual quality of the slides being talked to,
    and experimented with a post-hoc zoom. Overall, the post-processing
    stage took considerably longer than anticipated, but did add perceivable
    value and impact to the final video.
  bibtex: |
    @inproceedings{Gill:10:ImprovingVideo,
      title = {Improving the Presentation of Technical Material in Video Talks using Post Production},
      booktitle = {2010 Midwest Section Conference of the American Society for Engineering Education},
      year = {2010},
      month = {September},
      author = {Andy Gill and Garrin Kimmell and Kevin Matlage},
      what = {Minor},
    }

- key: Matlage-09-ChalkBoard
  cite: |
    K. Matlage and A. Gill, “Chalk<span>B</span>oard: <span>M</span>apping
    functions to polygons,” in *Proceedings of the Symposium on
    Implementation and Application of Functional Languages*, ser. LNCS, vol.
    6041. Springer-Verlag, Sep 2009.
  a_cite: |
    K. Matlage and A. Gill, “[Chalk<span>B</span>oard: <span>M</span>apping
    functions to polygons](/papers/Matlage-09-ChalkBoard),” in *Proceedings of the Symposium on
    Implementation and Application of Functional Languages*, ser. LNCS, vol.
    6041. Springer-Verlag, Sep 2009.
  year: 2009
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Matlage-09-ChalkBoard.pdf>
  abstract: |
    ChalkBoard is a domain specific language for describing images.
    The ChalkBoard language is uncompromisingly functional
    and encourages the use of modern functional idioms.
    ChalkBoard uses off-the-shelf
    graphics cards to speed up rendering of functional descriptions.
    In this paper, we
    describe the design of the core ChalkBoard language,
    and the architecture of our static image generation accelerator.
  bibtex: |
    @inproceedings{Matlage:09:ChalkBoard,
      author = {Kevin Matlage and Andy Gill},
      title = {Chalk{B}oard: {M}apping Functions to Polygons},
      booktitle = {Proceedings of the Symposium on Implementation and Application of Functional Languages},
      publisher = {Springer-Verlag},
      series = {LNCS},
      volume = {6041},
      month = {Sep},
      year = {2009},
    }

- key: Gill-09-KansasLava
  cite: |
    A. Gill, T. Bull, G. Kimmell, E. Perrins, E. Komp, and B. Werling,
    “Introducing <span>K</span>ansas <span>L</span>ava,” in *Proceedings of
    the Symposium on Implementation and Application of Functional
    Languages*, ser. LNCS, vol. 6041. Springer-Verlag, Sep 2009.
  a_cite: |
    A. Gill, T. Bull, G. Kimmell, E. Perrins, E. Komp, and B. Werling,
    “[Introducing <span>K</span>ansas <span>L</span>ava](/papers/Gill-09-KansasLava),” in *Proceedings of
    the Symposium on Implementation and Application of Functional
    Languages*, ser. LNCS, vol. 6041. Springer-Verlag, Sep 2009.
  year: 2009
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-09-KansasLava.pdf>
  abstract: |
    Kansas Lava is a domain specific language for hardware description.
    Though there have been a number of previous implementations of Lava,
    we have found the design space rich, with unexplored choices.
    We use a direct (Chalmers style)
    specification of circuits, and make significant use of Haskell
    overloading of standard classes, leading to concise circuit
    descriptions.
    Kansas Lava supports both simulation (inside GHCi),
    and execution via VHDL, by having a dual shallow and deep embedding
    inside our Signal type.
    We also have a lightweight sized-type mechanism,
    allowing for MATLAB style matrix based specifications to be directly
    expressed in Kansas Lava.
  bibtex: |
    @inproceedings{Gill:09:KansasLava,
      author = {Andy Gill and Tristan Bull and Garrin Kimmell and Erik Perrins and Ed Komp and Brett Werling},
      title = {Introducing {K}ansas {L}ava},
      booktitle = {Proceedings of the Symposium on Implementation and Application of Functional Languages},
      publisher = {Springer-Verlag},
      series = {LNCS},
      volume = {6041},
      month = {Sep},
      year = {2009},
    }

- key: Werling-09-ITC
  cite: |
    B. Werling, E. Perrins, and A. Gill, “Implementation of an
    <span>LDPC</span> decoder using functional programming languages,” in
    *Proceedings of the International Telemetering Conference*, Oct 2009,
    (Student Paper).
  a_cite: |
    B. Werling, E. Perrins, and A. Gill, “[Implementation of an
    <span>LDPC</span> decoder using functional programming languages](/papers/Werling-09-ITC),” in
    *Proceedings of the International Telemetering Conference*, Oct 2009,
    (Student Paper).
  year: 2009
  links:
  bibtex: |
    @inproceedings{Werling:09:ITC,
      author = {B. Werling and E. Perrins and A. Gill},
      title = {Implementation of an {LDPC} decoder using Functional Programming Languages},
      booktitle = {Proceedings of the International Telemetering Conference},
      location = {Las Vegas, NV},
      year = {2009},
      month = {Oct},
      note = {(Student Paper)},
      what = {Other},
    }

- key: Bull-09-ITC
  cite: |
    T. Bull, E. Perrins, and A. Gill, “Implementation of the viterbi
    algorithm using functional programming languages,” in *Proceedings of
    the International Telemetering Conference*, Oct 2009, (Student Paper).
  a_cite: |
    T. Bull, E. Perrins, and A. Gill, “[Implementation of the viterbi
    algorithm using functional programming languages](/papers/Bull-09-ITC),” in *Proceedings of
    the International Telemetering Conference*, Oct 2009, (Student Paper).
  year: 2009
  links:
  bibtex: |
    @inproceedings{Bull:09:ITC,
      author = {T. Bull and E. Perrins and A. Gill},
      title = {Implementation of the Viterbi Algorithm using Functional Programming Languages},
      booktitle = {Proceedings of the International Telemetering Conference},
      location = {Las Vegas, NV},
      year = {2009},
      month = {Oct},
      note = {(Student Paper)},
      what = {Other},
    }

- key: Gill-09-TypeSafeReification
  cite: |
    A. Gill, “Type-safe observable sharing in <span>H</span>askell,” in
    *Proceedings of the Second <span>ACM</span> <span>SIGPLAN</span>
    <span>H</span>askell Symposium*, ser. Haskell ’09. New York, NY, USA:
    ACM, Sep 2009, pp. 117–128.
  a_cite: |
    A. Gill, “[Type-safe observable sharing in <span>H</span>askell](/papers/Gill-09-TypeSafeReification),” in
    *Proceedings of the Second <span>ACM</span> <span>SIGPLAN</span>
    <span>H</span>askell Symposium*, ser. Haskell ’09. New York, NY, USA:
    ACM, Sep 2009, pp. 117–128.
  year: 2009
  links:
    - <http://doi.acm.org/10.1145/1596638.1596653>
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-09-TypeSafeReification.pdf>
  abstract: |
    Haskell is a great language for writing and supporting
    embedded Domain Specific Languages (DSLs).
    Some form of observable sharing
    is often a critical capability for allowing so-called deep DSLs
    to be compiled and processed. In this paper,
    we describe and explore uses of an IO function
    for reification which allows direct observation of sharing.
  bibtex: |
    @inproceedings{Gill:09:TypeSafeReification,
      author = {Andy Gill},
      title = {Type-Safe Observable Sharing in {H}askell},
      booktitle = {Proceedings of the Second {ACM} {SIGPLAN} {H}askell Symposium},
      year = {2009},
      month = {Sep},
      series = {Haskell '09},
      isbn = {978-1-60558-508-6},
      location = {Edinburgh, Scotland},
      pages = {117--128},
      doi = {10.1145/1596638.1596653},
      acmid = {1596653},
      publisher = {ACM},
      address = {New York, NY, USA},
      keywords = {DSL compilation, observable sharing},
    }

- key: Gill-2009-KUREDSL
  cite: |
    A. Gill, “A <span>H</span>askell hosted <span>DSL</span> for writing
    transformation systems,” in *Proceedings of the IFIP TC 2 Working
    Conference on Domain-Specific Languages*, ser. DSL ’09. Springer-Verlag,
    July 2009, pp. 285–309.
  a_cite: |
    A. Gill, “[A <span>H</span>askell hosted <span>DSL</span> for writing
    transformation systems](/papers/Gill-2009-KUREDSL),” in *Proceedings of the IFIP TC 2 Working
    Conference on Domain-Specific Languages*, ser. DSL ’09. Springer-Verlag,
    July 2009, pp. 285–309.
  year: 2009
  links:
    - <http://dx.doi.org/10.1007/978-3-642-03034-5_14>
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-09-KUREDSL.pdf>
  abstract: |
    KURE is a Haskell hosted Domain Specific Language (DSL)
    for writing transformation systems based on rewrite
    strategies.  When writing transformation systems, a
    significant amount of engineering effort goes into
    setting up plumbing to make sure that specific
    rewrite rules can fire.  Systems like Stratego and
    Strafunski provide most of this plumbing as
    infrastructure, allowing the DSL user to focus on
    the rewrites rules.  KURE is a strongly typed
    strategy control language in the tradition of
    Stratego and Strafunski.  It is intended for writing
    reasonably efficient rewrite systems, makes use of
    type families to provide a delimited generic
    mechanism for tree rewriting, and provides support
    for efficient identity rewrite detection. 
  bibtex: |
    @inproceedings{Gill:2009:KUREDSL,
      author = {Gill, Andy},
      title = {A {H}askell Hosted {DSL} for Writing Transformation Systems},
      booktitle = {Proceedings of the IFIP TC 2 Working Conference on Domain-Specific Languages},
      series = {DSL '09},
      year = {2009},
      month = {July},
      isbn = {978-3-642-03033-8},
      location = {Oxford, UK},
      pages = {285--309},
      numpages = {25},
      doi = {10.1007/978-3-642-03034-5_14},
      acmid = {1575968},
      publisher = {Springer-Verlag},
    }

- key: Kimmell-09-ICFPContestProblem
  cite: |
    G. Kimmell, K. Matlage, T. Bull, N. Frisby, A. Gill, M. Jantz, E. Komp,
    M. Peck, W. Peck, M. Snyder, and B. Werling, “The 2009 <span>ICFP</span>
    programming contest problem specification,” Information
    Telecommunication and Technology Center, University of Kansas, Lawrence,
    KS, Tech. Rep., June 2009.
  a_cite: |
    G. Kimmell, K. Matlage, T. Bull, N. Frisby, A. Gill, M. Jantz, E. Komp,
    M. Peck, W. Peck, M. Snyder, and B. Werling, “[The 2009 <span>ICFP</span>
    programming contest problem specification](/papers/Kimmell-09-ICFPContestProblem),” Information
    Telecommunication and Technology Center, University of Kansas, Lawrence,
    KS, Tech. Rep., June 2009.
  year: 2009
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Kimmell-09-ICFPContestProblem.pdf>
  bibtex: |
    @TechReport{Kimmell:09:ICFPContestProblem,
      author = {Garrin Kimmell and Kevin Matlage and
    	Tristan Bull and Nicolas Frisby and Andy Gill and
    	Michael Jantz and Ed Komp and Megan Peck and
    	Wesley Peck and  Mark Snyder and Brett Werling},
      title = {The 2009 {ICFP} Programming Contest Problem Specification},
      month = {June},
      year = {2009},
      institution = {Information Telecommunication and Technology Center, University of Kansas, Lawrence, KS},
    }

- key: PADL09
  cite: |
    A. Gill and T. Swift, Eds., *Practical Aspects of Declarative
    Languages*. Springer, LNCS 5418, January 2009.
  a_cite: |
    A. Gill and T. Swift, Eds., *Practical Aspects of Declarative
    Languages*. Springer, LNCS 5418, January 2009.
  year: 2009
  links:
  bibtex: |
    @proceedings{PADL09,
      title = {Practical Aspects of Declarative Languages},
      editor = {Andy Gill and Terrance Swift},
      publisher = {Springer, LNCS 5418},
      year = {2009},
      month = {January},
    }

- key: Gill-09-WW
  cite: |
    A. Gill and G. Hutton, “The worker/wrapper transformation,” *Journal of
    Functional Programming*, vol. 19, no. 2, pp. 227–251, March 2009.
  a_cite: |
    A. Gill and G. Hutton, “[The worker/wrapper transformation](/papers/Gill-09-WW),” *Journal of
    Functional Programming*, vol. 19, no. 2, pp. 227–251, March 2009.
  year: 2009
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-09-WW.pdf>
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-09-WW-extended.pdf>
  abstract: |
    The worker/wrapper transformation is a technique for changing the type
    of a computation, usually with the aim of improving its performance.
    It has been used by compiler writers for many years, but the technique
    is little-known in the wider functional programming community, and has
    never been described precisely.  In this article we explain, formalise,
    and explore the generality of the worker/wrapper transformation. We
    also provide a systematic recipe for its use as an equational reasoning
    technique for improving the performance of programs, and illustrate the
    power of this recipe using a range of examples.
  bibtex: |
    @article{Gill:09:WW,
      author = {Andy Gill and Graham Hutton},
      title = {The worker/wrapper transformation},
      journal = {Journal of Functional Programming},
      publisher = {Cambridge University Press},
      volume = {19},
      number = {2},
      pages = {227--251},
      month = {March},
      year = {2009},
    }

- key: Nordlander-2008-RecBinds08
  cite: |
    J. Nordlander, M. Carlsson, and A. J. Gill, “Unrestricted pure
    call-by-value recursion,” in *Proceedings of the 2008 ACM SIGPLAN
    workshop on ML*, ser. ML ’08. ACM, 2008, pp. 23–34.
  a_cite: |
    J. Nordlander, M. Carlsson, and A. J. Gill, “[Unrestricted pure
    call-by-value recursion](/papers/Nordlander-2008-RecBinds08),” in *Proceedings of the 2008 ACM SIGPLAN
    workshop on ML*, ser. ML ’08. ACM, 2008, pp. 23–34.
  year: 2008
  links:
    - <http://doi.acm.org/10.1145/1411304.1411309>
  abstract: |
    Call-by-value languages commonly restrict recursive
    definitions by only allowing functions and syntactically
    explicit values in the right-hand sides. As a
    consequence, some very appealing programming patterns
    that work well in lazy functional languages are hard to
    apply in a call-by-value setting, even though they might
    not be using laziness for any other purpose than to
    enable the desired form of recursion.
    
    In this paper we present an operational semantics as well
    as a straightforward implementation technique for
    unrestricted recursion under pure call-by-value.  On that
    basis we are able to demonstrate that highly recursive
    programming idioms such as combinator-based parsing are
    indeed compatible with call-by-value evaluation.
  bibtex: |
    @inproceedings{Nordlander:2008:RecBinds08,
      author = {Nordlander, Johan and Carlsson, Magnus and Gill, Andy J.},
      title = {Unrestricted pure call-by-value recursion},
      booktitle = {Proceedings of the 2008 ACM SIGPLAN workshop on ML},
      series = {ML '08},
      year = {2008},
      isbn = {978-1-60558-062-3},
      location = {Victoria, BC, Canada},
      pages = {23--34},
      numpages = {12},
      doi = {10.1145/1411304.1411309},
      acmid = {1411309},
      publisher = {ACM},
      keywords = {call-by-value, combinator libraries, implementation, semantics, value recursion},
    }

- key: Harrison-08-Asynchronous
  cite: |
    W. L. Harrison, G. Allwein, A. Gill, and A. Procter, “Asynchronous
    exceptions as an effect,” in *Ninth International Conference on
    Mathematics of Program Construction*. Springer-Verlag, July 2008.
  a_cite: |
    W. L. Harrison, G. Allwein, A. Gill, and A. Procter, “[Asynchronous
    exceptions as an effect](/papers/Harrison-08-Asynchronous),” in *Ninth International Conference on
    Mathematics of Program Construction*. Springer-Verlag, July 2008.
  year: 2008
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Harrison-08-Asynchronous.pdf>
  abstract: |
    Asynchronous interrupts abound in computing systems, yet
    they remain a thorny concept for both programming and
    verification practice.  The ubiquity of interrupts
    underscores the importance of developing programming
    models to aid the development and verification of
    interrupt-driven programs.  The research reported here
    recognizes asynchronous interrupts as a computational
    effect and encapsulates them as a building block in
    modular monadic semantics.  The resulting integrated
    semantic model can serve as both a guide for functional
    programming with interrupts and as a formal basis for
    reasoning about interrupt-driven computation as well.
  bibtex: |
    @inproceedings{Harrison:08:Asynchronous,
      author = {William L. Harrison and Gerard Allwein and Andy Gill and Adam Procter},
      title = {Asynchronous Exceptions as an Effect},
      booktitle = {Ninth International Conference on Mathematics of Program Construction},
      year = {2008},
      month = {July},
      publisher = {Springer-Verlag},
    }

- key: Gill-07-Hpc
  cite: |
    A. Gill and C. Runciman, “Haskell <span>P</span>rogram
    <span>C</span>overage,” in *Proceedings of the 2007 <span>ACM</span>
    <span>SIGPLAN</span> <span>W</span>orkshop on Haskell*. ACM Press,
    September 2007.
  a_cite: |
    A. Gill and C. Runciman, “[Haskell <span>P</span>rogram
    <span>C</span>overage](/papers/Gill-07-Hpc),” in *Proceedings of the 2007 <span>ACM</span>
    <span>SIGPLAN</span> <span>W</span>orkshop on Haskell*. ACM Press,
    September 2007.
  year: 2007
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-07-Hpc.pdf>
  abstract: |
    We describe the design, implementation and use of HPC,
    a tool-kit to record and display Haskell Program Coverage. HPC includes tools that
    instrument Haskell programs to record program coverage, run instrumented
    programs, and display information derived from coverage data in various ways.
  bibtex: |
    @inproceedings{Gill:07:Hpc,
      author = {Andy Gill and Colin Runciman},
      title = {Haskell {P}rogram {C}overage},
      booktitle = {Proceedings of the 2007 {ACM} {SIGPLAN} {W}orkshop on Haskell},
      year = {2007},
      month = {September},
      publisher = {ACM Press},
    }

- key: Marlow-07-GhciDebugger
  cite: |
    S. Marlow, J. Iborra, B. Pope, and A. Gill, “A lightweight interactive
    debugger for <span>H</span>askell,” in *Proceedings of the 2007
    <span>ACM</span> <span>SIGPLAN</span> <span>W</span>orkshop on Haskell*.
    ACM Press, September 2007.
  a_cite: |
    S. Marlow, J. Iborra, B. Pope, and A. Gill, “[A lightweight interactive
    debugger for <span>H</span>askell](/papers/Marlow-07-GhciDebugger),” in *Proceedings of the 2007
    <span>ACM</span> <span>SIGPLAN</span> <span>W</span>orkshop on Haskell*.
    ACM Press, September 2007.
  year: 2007
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Marlow-07-GhciDebugger.pdf>
  abstract: |
    This paper describes the design and construction of a Haskell
    source-level debugger built into the GHCi interactive environment.  We
    have taken a pragmatic approach: the debugger is based on the
    traditional stop-examine-continue model of online debugging, which is
    simple and intuitive, but has traditionally been shunned in the
    context of Haskell because it exposes the lazy evaluation order.  We
    argue that this drawback is not as severe as it may seem, and in some
    cases is an advantage.
    
    The design focuses on availability: our debugger is intended
    to work on all programs that can be compiled with GHC, and without
    requiring the programmer to jump through additional hoops to debug
    their program.  The debugger has a novel approach for reconstructing
    the type of runtime values in a polymorphic context.  Our
    implementation is light on complexity, and was integrated into GHC
    without significant upheaval.
  bibtex: |
    @inproceedings{Marlow:07:GhciDebugger,
      author = {Simon Marlow and Jos\'{e} Iborra and Bernard Pope and Andy Gill},
      title = {A lightweight interactive debugger for {H}askell},
      booktitle = {Proceedings of the 2007 {ACM} {SIGPLAN} {W}orkshop on Haskell},
      year = {2007},
      month = {September},
      publisher = {ACM Press},
    }

- key: Gill-06-IntroHERA
  cite: |
    A. Gill, “Introducing the <span>H</span>askell <span>E</span>quational
    <span>R</span>easoning <span>A</span>ssistant,” in *Proceedings of the
    2006 ACM SIGPLAN <span>W</span>orkshop on Haskell*. ACM Press, 2006, pp.
    108–109.
  a_cite: |
    A. Gill, “[Introducing the <span>H</span>askell <span>E</span>quational
    <span>R</span>easoning <span>A</span>ssistant](/papers/Gill-06-IntroHERA),” in *Proceedings of the
    2006 ACM SIGPLAN <span>W</span>orkshop on Haskell*. ACM Press, 2006, pp.
    108–109.
  year: 2006
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-06-IntroHERA.pdf>
  abstract: |
    We introduce the new, improved version of the
    Haskell Equational Reasoning Assistant, which consists
    of an Ajax application for rewriting Haskell fragments
    in their context, and an API for scripting non-trivial rewrites.
  bibtex: |
    @inproceedings{Gill:06:IntroHERA,
      author = {Andy Gill},
      title = {Introducing the {H}askell {E}quational {R}easoning {A}ssistant},
      booktitle = {Proceedings of the 2006 ACM SIGPLAN {W}orkshop on Haskell},
      year = {2006},
      pages = {108--109},
      isbn = {1-59593-489-8},
      location = {Portland, Oregon, USA},
      publisher = {ACM Press},
    }

- key: Moran-01-Legacy
  cite: |
    A. Moran, J. Teisher, A. Gill, E. Pasalic, and J. Veneruso, “Automated
    translation of legacy code for <span>ATE</span>,” in *Proceedings of the
    IEEE International Test Conference*. IEEE Computer Society, 2001, pp.
    148–156.
  a_cite: |
    A. Moran, J. Teisher, A. Gill, E. Pasalic, and J. Veneruso, “[Automated
    translation of legacy code for <span>ATE</span>](/papers/Moran-01-Legacy),” in *Proceedings of the
    IEEE International Test Conference*. IEEE Computer Society, 2001, pp.
    148–156.
  year: 2001
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Moran-01-Legacy.pdf>
  abstract: |
    When an Automated Testing Equipment (ATE) company
    designs a new system, the issue of backward compatibility is
    always a major concern, both for the company and its
    customers. If backward compatibility is maintained, the ATE
    application engineers face the difficult task of trying to
    support new features on an aging system. The alternative is
    to face the problem of converting old test programs to the
    new environment. Translation of legacy code involves an
    automatic translation tool, and some application effort
    applied to those problems the translator couldn't
    resolve. To minimize the amount of work required from the
    application engineers, the tool needs to be
    semantically aware; that is, the tool must contain
    domain specific knowledge and use that knowledge when
    translating. The more knowledge a tool has at its disposal,
    the less code an application engineer is forced to translate
    by hand.
    
    Until recently, it has been difficult to perform automatic
    translation satisfactorily because it was not cost effective
    to write a translator that possessed such semantic
    understanding of the test programs. By making good use of
    Functional Programming techniques and tools, we were able to
    construct a cost effective, semantically aware translation
    tool in a fraction of the time needed by traditional
    methods. Based upon its performance during testing, we
    believe the tool to correctly translate the majority of
    test programs, thereby greatly easing the applications
    engineers' burden.
  bibtex: |
    @inproceedings{Moran:01:Legacy,
      author = {Andrew Moran and Jim Teisher and Andrew Gill and Emir Pasalic and John Veneruso},
      title = {Automated translation of legacy code for {ATE}},
      booktitle = {Proceedings of the IEEE International Test Conference},
      year = {2001},
      isbn = {0-7803-7169-0},
      pages = {148--156},
      publisher = {IEEE Computer Society},
    }

- key: Gill-00-HOOD
  cite: |
    A. Gill, “Debugging <span>H</span>askell by observing intermediate data
    structures,” in *Proceedings of the 2000 ACM SIGPLAN
    <span>W</span>orkshop on Haskell, Technical report of the University of
    Nottingham*, 2000.
  a_cite: |
    A. Gill, “[Debugging <span>H</span>askell by observing intermediate data
    structures](/papers/Gill-00-HOOD),” in *Proceedings of the 2000 ACM SIGPLAN
    <span>W</span>orkshop on Haskell, Technical report of the University of
    Nottingham*, 2000.
  year: 2000
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-00-HOOD.pdf>
  abstract: |
    Haskell has long needed a debugger. Although there has
    been much research into the topic of debugging lazy functional
    programs, no robust tool has yet come from the Haskell community
    that can help debug full Haskell - until now. This paper describes
    a portable debugger for full Haskell, building only on commonly
    implemented extensions. It is based on the concept of observation
    of intermediate data structures, rather than the more traditional
    stepping and variable examination paradigm used by traditional
    imperative debuggers.
  bibtex: |
    @inproceedings{Gill:00:HOOD,
      author = {Andy Gill},
      title = {Debugging {H}askell by observing intermediate data structures},
      booktitle = {Proceedings of the 2000 ACM SIGPLAN {W}orkshop on Haskell,
                       Technical report of the University of Nottingham},
      year = {2000},
    }

- key: Okasaki-98-IntMap
  cite: |
    C. Okasaki and A. Gill, “Fast mergeable integer maps,” in *ACM SIGPLAN
    Workshop on ML*, September 1998, pp. 77–86.
  a_cite: |
    C. Okasaki and A. Gill, “[Fast mergeable integer maps](/papers/Okasaki-98-IntMap),” in *ACM SIGPLAN
    Workshop on ML*, September 1998, pp. 77–86.
  year: 1998
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Okasaki-98-IntMap.pdf>
  abstract: |
    Finite maps are ubiquitous in many applications, but
    perhaps nowhere more so than in compilers and other language
    processors. In these applications, three operations on finite
    maps dominate all others: looking up the value associated with
    a key, inserting a new binding, and merging two finite
    maps. Most implementations of finite maps in functional
    languages are based on balanced binary search trees, which
    perform well on the first two, but poorly on the third. We
    describe an implementation of finite maps with integer keys
    that performs well in practice on all three operations. This
    data structure is not new-indeed, it is thirty years old this
    year-but it deserves to be more widely known.
  bibtex: |
    @inproceedings{Okasaki:98:IntMap,
      author = {Chris Okasaki and Andy Gill},
      title = {Fast mergeable integer maps},
      pages = {77--86},
      booktitle = {ACM SIGPLAN Workshop on ML},
      year = {1998},
      month = {September},
    }

- key: Gill-96-PhD
  cite: |
    A. Gill, “Cheap deforestation for non-strict functional languages,”
    Ph.D. dissertation, The University of Glasgow, January 1996.
  a_cite: |
    A. Gill, “[Cheap deforestation for non-strict functional languages](/papers/Gill-96-PhD),”
    Ph.D. dissertation, The University of Glasgow, January 1996.
  year: 1996
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-96-PhD.pdf>
  abstract: |
    In functional languages intermediate data structures are
    often used as ''glue'' to connect separate parts of a program
    together. Deforestation is the process of automatically removing
    intermediate data structures. In this thesis we present and analyse a
    new approach to deforestation. This new approach is both practical and
    general.
    
    We analyse in detail the problem of list removal rather than
    the more general problem of arbitrary data structure removal. This
    more limited scope allows a complete evaluation of the pragmatic
    aspects of using our deforestation technology.
    
    We have implemented our list deforestation algorithm in the
    Glasgow Haskell compiler. Our implementation has allowed
    practical feedback. One important conclusion is that a new
    analysis is required to infer function arities and the
    linearity of lambda abstractions. This analysis renders the
    basic deforestation algorithm far more effective.
    
    We give a detailed assessment of our implementation of
    deforestation. We measure the effectiveness of our
    deforestation on a suite of real application programs. We
    also observe the costs of our deforestation algorithm.
  bibtex: |
    @phdthesis{Gill:96:PhD,
      author = {Andrew Gill},
      title = {Cheap deforestation for non-strict functional languages},
      school = {The University of Glasgow},
      month = {January},
      year = {1996},
    }

- key: Gill-95-TechGUIHERA
  cite: |
    A. Gill, “The technology behind a graphical user interface for an
    equational reasoning assistant,” in *Proceedings of the 1995 Glasgow
    Workshop on Functional Programming, Electronic Workshops in Computing,
    Ullapool, Scotland*, 1995.
  a_cite: |
    A. Gill, “[The technology behind a graphical user interface for an
    equational reasoning assistant](/papers/Gill-95-TechGUIHERA),” in *Proceedings of the 1995 Glasgow
    Workshop on Functional Programming, Electronic Workshops in Computing,
    Ullapool, Scotland*, 1995.
  year: 1995
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-95-TechGUIHERA.pdf>
  abstract: |
    The Haskell Equational Reasoning Assistant (HERA) is an application
    written in Haskell that helps users construct and present equational
    reasoning style proofs. In this paper we discuss the technology behind
    HERA's graphical user interface.
  bibtex: |
    @inproceedings{Gill:95:TechGUIHERA,
      author = {Andy Gill},
      title = {The technology behind a graphical user interface for an equational reasoning assistant},
      booktitle = {Proceedings of the 1995 Glasgow Workshop on Functional Programming,
                       Electronic Workshops in Computing, Ullapool, Scotland},
      year = {1995},
    }

- key: Gill-94-CheapDeforestationPrac
  cite: |
    A. Gill and S. <span>Peyton Jones</span>, “Cheap deforestation in
    practice: An optimizer for <span>H</span>askell,” in *IFIP Congress
    (1)*, 1994, pp. 581–586.
  a_cite: |
    A. Gill and S. <span>Peyton Jones</span>, “[Cheap deforestation in
    practice: An optimizer for <span>H</span>askell](/papers/Gill-94-CheapDeforestationPrac),” in *IFIP Congress
    (1)*, 1994, pp. 581–586.
  year: 1994
  links:
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-94-CheapDeforestationPrac.pdf>
  abstract: |
    We present a simple, automatic transformation - the
    foldr/build transformation - which successfully removes many
    intermediate lists from programs written in non-strict functional
    programming languages. While the idea is simple and elegant, it
    turns out that some care is needed in the compiler to set up the
    right conditions for the foldr/build transformation to be
    applicable. We report on this practical experience, and present
    results which quantify the benefits that can in practice be
    achieved.
  bibtex: |
    @inproceedings{Gill:94:CheapDeforestationPrac,
      author = {Andrew Gill and Simon {Peyton Jones}},
      title = {Cheap Deforestation in Practice: An Optimizer for {H}askell},
      booktitle = {IFIP Congress (1)},
      year = {1994},
      pages = {581--586},
    }

- key: Gill-93-ShortCutFusion
  cite: |
    A. Gill, J. Launchbury, and S. <span>Peyton Jones</span>, “A short cut
    to deforestation,” in *FPCA ’93: Proceedings of the conference on
    Functional Programming Languages and Computer Architecture*. ACM Press,
    1993, pp. 223–232.
  a_cite: |
    A. Gill, J. Launchbury, and S. <span>Peyton Jones</span>, “[A short cut
    to deforestation](/papers/Gill-93-ShortCutFusion),” in *FPCA ’93: Proceedings of the conference on
    Functional Programming Languages and Computer Architecture*. ACM Press,
    1993, pp. 223–232.
  year: 1993
  links:
    - <http://dl.acm.org/citation.cfm?doid=165180.165214>
    - <http://www.ittc.ku.edu/csdl/fpg/files/Gill-93-ShortCutFusion.pdf>
  abstract: |
    Lists are often used as "glue" to connect separate
    parts of a program together. We propose an automatic technique for
    improving the efficiency of such programs, by removing many of these
    intermediate lists, based on a single, simple, local
    transformation. We have implemented the method in the Glasgow
    Haskell compiler.
  bibtex: |
    @inproceedings{Gill:93:ShortCutFusion,
      author = {Andrew Gill and John Launchbury and Simon {Peyton Jones}},
      title = {A short cut to deforestation},
      booktitle = {FPCA '93: Proceedings of the conference on Functional Programming Languages and Computer Architecture},
      year = {1993},
      isbn = {0-89791-595-X},
      pages = {223--232},
      location = {Copenhagen, Denmark},
      doi = {http://doi.acm.org/10.1145/165180.165214},
      publisher = {ACM Press},
    }

- key: Gill-92-Avoid
  cite: |
    J. Launchbury, A. Gill, J. Hughes, S. Marlow, S. <span>Peyton
    Jones</span>, and P. Wadler, “Avoiding unnecessary updates,” in *Glasgow
    Workshop on Functional Programming, Workshops in Computing*.
    Springer-Verlag, 1992, pp. 144–153.
  a_cite: |
    J. Launchbury, A. Gill, J. Hughes, S. Marlow, S. <span>Peyton
    Jones</span>, and P. Wadler, “[Avoiding unnecessary updates](/papers/Gill-92-Avoid),” in *Glasgow
    Workshop on Functional Programming, Workshops in Computing*.
    Springer-Verlag, 1992, pp. 144–153.
  year: 1992
  links:
  abstract: |
    Graph reduction underlies most implementations of lazy functional
    languages, allowing separate computations to share results when
    sub-terms are evaluated. Once a term is evaluated, the node of the
    graph representing the computation is updated with the value of
    the term. However, in many cases, no other computation requires
    this value, so the update is unnecessary. In this paper we take
    some steps towards an analysis for determining when these updates
    may be omitted.
  bibtex: |
    @inproceedings{Gill:92:Avoid,
      author = {John Launchbury and Andrew Gill and John Hughes and Simon Marlow and Simon {Peyton Jones} and Philip Wadler},
      title = {Avoiding Unnecessary Updates},
      booktitle = {Glasgow Workshop on Functional Programming, Workshops in Computing},
      pages = {144-153},
      year = {1992},
      location = {Ayr, Scotland},
      publisher = {Springer-Verlag},
    }

- key: Gill-91-NovelPeep
  cite: |
    A. Gill, “A novel approach towards peephole optimisations,” in
    *Proceedings of the 1991 Glasgow Workshop on Functional Programming*,
    ser. Workshops in Computing, R. Heldal, C. K. Holst, and P. Wadler, Eds.
    Springer, August 1991, pp. 100–111.
  a_cite: |
    A. Gill, “[A novel approach towards peephole optimisations](/papers/Gill-91-NovelPeep),” in
    *Proceedings of the 1991 Glasgow Workshop on Functional Programming*,
    ser. Workshops in Computing, R. Heldal, C. K. Holst, and P. Wadler, Eds.
    Springer, August 1991, pp. 100–111.
  year: 1991
  links:
  abstract: |
    In this paper we examine alternative approaches towards the
    traditional optimisation technique of peepholing. Three simple
    methods of generating quality code are given. The first method
    improves poor juxtapositions while generating code, the second is
    an alternative usage of a solution to the knapsack problem. A
    third hybrid algorithm combines the strong points of both these
    solutions, and is presented as an alternative to conventional
    peepholing.
  bibtex: |
    @inproceedings{Gill:91:NovelPeep,
      author = {Andrew Gill},
      title = {A Novel Approach Towards Peephole Optimisations},
      booktitle = {Proceedings of the 1991 Glasgow Workshop on Functional Programming},
      year = {1991},
      month = {August},
      pages = {100--111},
      editor = {Rogardt Heldal and
                   Carsten Kehler Holst and
                   Philip Wadler},
      publisher = {Springer},
      series = {Workshops in Computing},
      isbn = {3-540-19760-5},
    }

