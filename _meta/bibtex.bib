// These are bib entries that would appear on ITTC / CSDL websites
// Its in reverse chronological order.
// There is typically more meta-data, like contribution percent, acceptance rate, etc.

// ------------------------------------------------------------------------------
// In prep

// ------------------------------------------------------------------------------
// Submitted




// ------------------------------------------------------------------------------
// Published

@incollection{Gill:17:AFrameDSL,
 author = {Gill, Andy},
 title = {AFrame: A Domain Specific Language for Virtual Reality: Extended Abstract},
 booktitle = {Proceedings of the 2nd International Workshop on Real World Domain Specific Languages},
 series = {RWDSL17},
 year = {2017},
 isbn = {978-1-4503-4845-4},
 location = {Austin, TX, USA},
 url = {http://doi.acm.org/10.1145/3039895.3039899},
 doi = {10.1145/3039895.3039899},
 acmid = {3039899},
 keywords = {DSLs, HTML5, Virtual Reality},
 abstract = "Do Domain Specific Languages (DSLs) have anything to contribute towards the building and animating of three-dimensional scenes for Virtual Reality (VR)? Yes! AFrame is a DSL, and a widely-supported HTML5 extension for building virtual reality experiences. AFrame is open-source, actively developed by Mozilla, and works inside most modern browsers, including mobile browsers. Customizable web-based delivery of VR experiences is possible, because AFrame is a DSL."
} 

@incollection{Grebe:17:HaskinoThreads,
  year={2017},
  booktitle = "Post-Proceedings of Trends in Functional Programming",
  pubstate={inpress},
  title={Threading the {A}rduino with {H}askell},
  xurl= "http://www.ittc.ku.edu/csdl/fpg/files/Grebe-17-HaskinoThreads.pdf",
  author={Grebe, Mark and Gill, Andy},
  abstract={Programming embedded microcontrollers often requires the scheduling of
            independent threads of execution, specifying the interaction and sequencing
            of actions in the multiple threads.  Developing and debugging such multi-threaded
            systems can be especially challenging in highly resource constrained systems
            such as the Arduino line of microcontroller boards.  The Haskino library, developed
            at the University of Kansas, allows programmers to develop code for
            Arduino-based microcontrollers using monadic Haskell program fragments.
            This paper describes our efforts to extend the Haskino library to
            translate monadic Haskell code to multi-threaded code executing on Arduino boards.}
}

@incollection{Grebe:16:Haskino,
  year={2016},
  booktitle={Practical Aspects of Declarative Languages},
  series={Lecture Notes in Computer Science},
  title={{H}askino: A Remote Monad for Programming the {A}rduino},
  xurl= "http://www.ittc.ku.edu/csdl/fpg/files/Grebe-16-Haskino.pdf",
  author={Grebe, Mark and Gill, Andy},
  abstract={The Haskino library provides a mechanism for programming the Arduino
            microcontroller boards in high level, strongly typed Haskell instead of the
            low level C language normally used.
            Haskino builds
            on previous libraries for Haskell based Arduino programming by utilizing the
            recently developed remote monad design pattern.
            This paper presents the design and implementation
            of the two-level Haskino library.
            This first level
            of Haskino requires communication from the host running the Haskell program and
            the target Arduino over a serial link.  We then investigate extending the
            initial version of the library with a
            deep embedding allowing us to cut the cable, and run the
            Arduino as an independent system.}
}


@inproceedings{Gill:15:RemoteMonad,
  author="Andy Gill and Neil Sculthorpe and Justin Dawson and
                  Aleksander Eskilson and Andrew Farmer and Mark Grebe
                  and Jeffrey Rosenbluth and Ryan Scott and James
                  Stanton",
  title="The Remote Monad Design Pattern",
  booktitle = {Proceedings of the 8th ACM SIGPLAN Symposium on Haskell},
  location     = "Vancouver, BC, Canada",
  publisher    = "ACM",
  year         = 2015,
  pages = {59--70},
  numpages = {12},
  url = {http://doi.acm.org/10.1145/2804302.2804311},
  doi = {10.1145/2804302.2804311},
  publisher = {ACM},
  address = {New York, NY, USA},
  keywords = {Design Pattern, FFI, Monads, Remote Procedure Call},

  abstract="Remote Procedure Calls are expensive.  This paper
                  demonstrates how to reduce the cost of calling
                  remote procedures from Haskell by using the
                  \emph{remote monad design pattern}, which amortizes
                  the cost of remote calls.  This gives the Haskell
                  community access to remote capabilities that are not
                  directly supported, at a surprisingly inexpensive
                  cost.

                  We explore the remote monad design pattern
                  through six models of remote execution patterns,
                  using a simulated Internet of Things toaster as a
                  running example.  We consider the expressiveness and
                  optimizations enabled by each remote execution
                  model, and assess the feasibility of our approach.
                  We then present a full-scale case study: a Haskell
                  library that provides a Foreign Function Interface
                  to the JavaScript Canvas API.  Finally, we discuss
                  existing instances of the remote monad design
                  pattern found in Haskell libraries.",
  url  = {http://dl.acm.org/citation.cfm?id=2804311},
  xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Gill-15-RemoteMonad.pdf},
  xxurl= {https://www.youtube.com/watch?v=guMLPr6eBLo},
  xcontent = "
#### Disclaimer

This is the author's version of the work. It is posted here for your
personal use. Not for redistribution.
The definitive version was published in Haskell 2015, and is available
in the ACM Digital Library."

}

@inproceedings{Farmer:15:HERMIT-reasoning,
  author       = "Andrew Farmer and Neil Sculthorpe and Andy Gill",
  title        = "Reasoning with the {HERMIT}: {T}ool Support for Equational Reasoning on {GHC} {C}ore Programs",
  booktitle = {Proceedings of the 8th ACM SIGPLAN Symposium on Haskell},
  series = {Haskell 2015},
  location = {Vancouver, BC, Canada},
  year         = 2015,
  isbn = {978-1-4503-3808-0},
  location = {Vancouver, BC, Canada},
  pages = {23--34},
  numpages = {12},
  url = {http://doi.acm.org/10.1145/2804302.2804303},
  doi = {10.1145/2804302.2804303},
  acmid = {2804303},
  publisher = {ACM},
  address = {New York, NY, USA},
  keywords = {Equational Reasoning, HERMIT, Type Class Laws},

  abstract="A benefit of pure functional programming is that it
                  encourages \emph{equational reasoning}.  However,
                  the Haskell language has lacked direct tool support
                  for such reasoning.  Consequently, reasoning about
                  Haskell programs is either performed manually, or in
                  another language that does provide tool support
                  (e.g. Agda or Coq).  HERMIT is a Haskell-specific
                  toolkit designed to support equational reasoning and
                  user-guided program transformation, and to do so as
                  part of the GHC compilation pipeline.  This paper
                  describes HERMIT's recently developed support for
                  equational reasoning, and presents two case studies
                  of HERMIT usage: checking that type-class laws hold
                  for specific instance declarations, and mechanising
                  textbook equational reasoning.",
  url  = {http://dx.doi.org/10.1145/2804302.2804311},
  xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Farmer-15-HERMIT-reasoning.pdf},
  xcontent = "
 #### Disclaimer

This is the author's version of the work. It is posted here for your
personal use. Not for redistribution.
The definitive version was published in Haskell 2015, and is available
in the [ACM Digital Library](http://dx.doi.org/10.1145/2804302.2804311).

 #### Case Studies

 Download the case studies here: [Reasoning with the HERMIT Case Studies](/files/Reasoning-with-the-HERMIT-5.tgz)

 Instructions for installing HERMIT (cabal update ; cabal install hermit-1.0.0.0) and running the case studies can be found in the README file contained within the case study archive.",
  xredirect = "/HERMIT/case-studies-2015/",
}

}



@article{Adams:15:OSTIE,
    author   = "Michael D. Adams and Andrew Farmer and Jos\'{e} Pedro {Magalh\~{a}es}",
    title    = "Optimizing {SYB} {Traversals} {Is} {Easy}!",
    journal  = "Science of Computer Programming",
    volume   = "112, Part 2",
    number   = "",
    pages    = "170 - 193",
    year     = 2015,
    note     = "Selected and extended papers from Partial Evaluation and Program Manipulation 2014",
    issn     = "0167-6423",
    doi      = {10.1016/j.scico.2015.09.003},
    url      = "http://www.sciencedirect.com/science/article/pii/S0167642315002622",
    xurl     = {http://www.ittc.ku.edu/csdl/fpg/files/Adams-15-OSTIE-preprint.pdf},
    abstract = "The most widely used generic-programming system in the Haskell community,
                Scrap Your Boilerplate (SYB), also happens to be one of the slowest. Generic
                traversals in SYB are often an order of magnitude slower than equivalent handwritten,
                non-generic traversals. Thus while SYB allows the concise expression
                of many traversals, its use incurs a significant runtime cost. Existing techniques
                for optimizing other generic-programming systems are not able to eliminate this
                overhead.

                This paper presents an optimization that eliminates this cost. Essentially, it
                is a partial evaluation that takes advantage of domain-specific knowledge about
                the structure of SYB. It optimizes SYB traversals to be as fast as handwritten,
                non-generic code, and benchmarks show that this optimization improves the
                speed of SYB traversals by an order of magnitude or more."
}

@phdthesis{Farmer:15:PhD,
   author   = {Andrew Farmer},
   title    = {{HERMIT}: {M}echanized {R}easoning during {C}ompilation in the {G}lasgow {H}askell {C}ompiler},
   school   = {The University of Kansas},
   month    = {April},
   year     = 2015,
   xurl     = {http://www.ittc.ku.edu/csdl/fpg/files/Farmer-15-Dissertation.pdf},
   abstract = {It is difficult to write programs which are both correct and fast.
A promising approach, functional programming, is based on the idea of using pure,
mathematical functions to construct programs.
With effort, it is possible to establish a connection between a specification written in a functional language,
which has been proven correct, and a fast implementation, via program transformation.

When practiced in the functional programming community, this style of reasoning is still typically performed by hand,
by either modifying the source code or using pen-and-paper.
Unfortunately, performing such semi-formal reasoning by directly modifying the source code often obfuscates
the program, and pen-and-paper reasoning becomes outdated as the program changes over time.
Even so, this semi-formal reasoning prevails because formal reasoning is time-consuming, and requires considerable
expertise.
Formal reasoning tools often only work for a subset of the target language, or require programs to be implemented in
a custom language for reasoning.

This dissertation investigates a solution, called HERMIT, which mechanizes reasoning during compilation.
HERMIT can be used to prove properties about programs written in the Haskell functional programming language,
or transform them to improve their performance.
Reasoning in HERMIT proceeds in a style familiar to practitioners of pen-and-paper reasoning, and
mechanization allows these techniques to be applied to real-world programs with greater confidence.
HERMIT can also re-check recorded reasoning steps on subsequent compilations,
enforcing a connection with the program as the program is developed.

HERMIT is the first system capable of directly reasoning about the full Haskell language.
The design and implementation of HERMIT, motivated both by typical reasoning tasks and HERMIT's place in the Haskell
ecosystem, is presented in detail.
Three case studies investigate HERMIT's capability to reason in practice.
These case studies demonstrate that semi-formal reasoning with HERMIT lowers the barrier to writing programs which are both
correct and fast.}
}


@mastersthesis { Torrence:15:Life,
  author       = "Brad Torrence",
  title        = "{The Life Changing {HERMIT}: A Case Study of the Worker/Wrapper Transformation}",
  school       = "The University of Kansas",
  year         = 2015,
  month        = "January",
  xurl     = {http://www.ittc.ku.edu/csdl/fpg/files/Torrence-15-MS.pdf},
  abstract     = "In software engineering, altering a program’s
                  original implementation disconnects it from the
                  model that produced it. Reconnecting the model and
                  new implementations must be done in a way that does
                  not decrease confidence in the design’s correctness
                  and performance. This thesis demonstrates that it is
                  possible, in practice, to connect the model of
                  Conway’s Game of Life with new implementations,
                  using the worker/wrapper transformation
                  theory. This connection allows development to
                  continue without the sacrifice of reimplementation.

                  HERMIT is a tool that allows programs implemented in
                  Haskell to be transformed during the compilation
                  process, and has features capable of performing
                  worker/wrapper transformations. Specifically in
                  these experiments, HERMIT is used to apply syntax
                  transformations to replace Life’s linked-list based
                  implementation with one that uses other data
                  structures in an effort to explore alternative
                  implementations and improve overall performance.

                  Previous work has successfully performed the
                  worker/wrapper conversion on an individual
                  function using HERMIT. This thesis presents the
                  first time that a programmer-directed
                  worker/wrapper transformation has been attempted on
                  an entire program. From this experiment, substantial
                  observations have been made. These observations have
                  led to proposed improvements to the HERMIT system,
                  as well as the formal approach to the worker/wrapper
                  transformation process."
}

@article{Sculthorpe:14:KURE,
    author       = "Neil Sculthorpe and Nicolas Frisby and Andy Gill",
    title        = "The {K}ansas {U}niversity {R}ewrite {E}ngine: A {H}askell-Embedded Strategic Programming Language with Custom Closed Universes",
    url          = "http://journals.cambridge.org/article_S956796814000187",
    xurl         = "http://www.ittc.ku.edu/csdl/fpg/files/Sculthorpe-14-KURE.pdf",
    journal      = "Journal of Functional Programming",
    publisher    = "Cambridge University Press",
    year         = 2014,
    volume = {24},
    issue = {04},
    month = {7},
    issn = {1469-7653},
    pages = {434--473},
    numpages = {40},
    doi = {10.1017/S0956796814000185},
    abstract   = {When writing transformation systems, a significant
                  amount of engineering effort goes into setting up
                  the infrastructure needed to direct individual
                  transformations to specific targets in the data
                  being transformed.  Strategic programming languages
                  provide general-purpose infrastructure for this
                  task, which the author of a transformation system
                  can use for any algebraic data structure.  The
                  Kansas University Rewrite Engine (KURE) is a typed
                  strategic programming language, implemented as a
                  Haskell-embedded domain-specific language. KURE is
                  designed to support typed transformations over typed
                  data, and the main challenge is how to make such
                  transformations compatible with generic traversal
                  strategies that should operate over any type.
                  Strategic programming in a typed setting has much in
                  common with datatype-generic programming.  Compared
                  to other approaches to datatype-generic programming,
                  the distinguishing feature of KURE's solution is
                  that the user can configure the behaviour of
                  traversals based on the location of each datum in
                  the tree, beyond their behaviour being determined by
                  the type of each datum.  This article describes
                  KURE's approach to assigning types to generic
                  traversals, and the implementation of that approach.
                  We also compare KURE, its design choices, and their
                  consequences, with other approaches to strategic and
                  datatype-generic programming.}
}

@article{Gill:14:DSLs-and-Synthesis,
 author = {Gill, Andy},
 title = {Domain-specific Languages and Code Synthesis Using {H}askell},
 journal = {Commun. ACM},
 issue_date = {June 2014},
 volume = {57},
 number = {6},
 month = {June},
 year = {2014},
 issn = {0001-0782},
 pages = {42--49},
 numpages = {8},
 url = {http://doi.acm.org/10.1145/2605205},
 xurl={https://queue.acm.org/detail.cfm?id=2617811},
 doi = {10.1145/2605205},
 acmid = {2605205},
 publisher = {ACM},
 address = {New York, NY, USA},
 note = "Also appeared in ACM Queue, Vol 12(4), April 2014"
}

@incollection{Bracker:14:Sunroof,
  year={2014},
  isbn={978-3-319-04131-5},
  booktitle={Practical Aspects of Declarative Languages},
  volume={8324},
  series={Lecture Notes in Computer Science},
  editor={Flatt, Matthew and Guo, Hai-Feng},
  doi={10.1007/978-3-319-04132-2_5},
  title={Sunroof: A Monadic {DSL} for Generating {J}ava{S}cript},
  url={http://dx.doi.org/10.1007/978-3-319-04132-2_5},
  xurl= "http://www.ittc.ku.edu/csdl/fpg/files/Bracker-14-Sunroof.pdf",
  publisher={Springer International Publishing},
  keywords={DSLs; JavaScript; Web Technologies; Cloud Computing},
  author={Bracker, Jan and Gill, Andy},
  pages={65-80},
abstract={Sunroof is a Haskell-hosted Domain Specific Language (DSL)
                  for generating JavaScript. The central feature of
                  Sunroof is a JavaScript monad, which, like the
                  Haskell IO-monad, allows access to external
                  resources, but specifically JavaScript resources. As
                  such, Sunroof is primarily a feature-rich
                  foreign-function API to the browser’s JavaScript
                  engine, and all the browser-specific functionality,
                  including HTML-based rendering, event handling, and
                  drawing to the HTML5 canvas element.

                  In this paper,
                  we give the design and implementation of
                  Sunroof. Using monadic reification, we generate
                  JavaScript from a deep embedding of the JavaScript
                  monad. The Sunroof DSL has the feel of native
                  Haskell, with a simple Haskell-based type schema to
                  guide the Sunroof programmer. Furthermore, because
                  we are generating code, we can offer Haskell-style
                  concurrency patterns, such as MVars and Channels. In
                  combination with a web-services package, the Sunroof
                  DSL offers a robust platform to build interactive
                  web applications.}
}

@inproceedings{Farmer:14:HERMITinStream,
    author = "Andrew Farmer and Christian {H\"{o}ner zu Siederdissen} and Andy Gill",
    title  = "The {HERMIT} in the {Stream}",
    booktitle = "Proceedings of the 2014 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation",
    series = "PEPM '14",
    publisher = "ACM",
    location = "San Diego, California, USA",
    year   = 2014,
  xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Farmer-14-HERMITinStream.pdf},
    abstract = "Stream Fusion, a popular deforestation technique in the Haskell community, cannot fuse the concatMap combinator. This is a serious limitation, as concatMap represents computations on nested streams. The original implementation of Stream Fusion used the Glasgow Haskell Compiler’s user-directed rewriting system. A transformation which allows the compiler to fuse many uses of concatMap has previously been proposed, but never implemented, because the host rewrite system was not expressive enough to implement the proposed transformation. In this paper, we develop a custom optimization plugin which implements the proposed concatMap transformation, and study the effectiveness of the transformation in practice. We also provide a new translation scheme for list comprehensions which enables them to be optimized. Within this framework, we extend the transformation to monadic streams. Code featuring uses of concatMap experiences significant speedup when compiled with this optimization. This allows Stream Fusion to outperform its rival, foldr/build, on many list computations, and enables performance-sensitive code to be expressed at a higher level of abstraction."
}

@inproceedings{Adams:14:OSIE,
    author = "Michael D. Adams and Andrew Farmer and Jos\'{e} Pedro {Magalh\~{a}es}",
    title  = "Optimizing {SYB} {Is} {Easy}!",
    booktitle = "Proceedings of the 2014 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation",
    series = "PEPM '14",
    publisher = "ACM",
    location = "San Diego, California, USA",
    year   = 2014,
  xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Adams-14-OSIE.pdf},
    note     = "Won Best Paper Award",
    abstract = "The most widely used generic-programming system in the Haskell community, Scrap Your Boilerplate (SYB), also happens to be one of the slowest. Generic traversals in SYB are about an order of magnitude slower than equivalent handwritten, non-generic traversals. Thus while SYB allows the concise expression of many traversals, its use incurs a significant runtime cost. Existing techniques for optimizing other generic-programming systems are not able to eliminate this overhead.

This paper presents an optimization that completely eliminates this cost. The optimization takes advantage of domain-specific knowledge about the structure of SYB and in so doing can optimize SYB-style traversals to be as fast as handwritten, non-generic code.

This paper presents both the formal structure of the optimization and the results of benchmarking the optimized SYB code against both unoptimized SYB code and handwritten, non-generic code. In these benchmarks, the optimized SYB code matches the performance of handwritten code even when the unoptimized SYB code is an order of magnitude or more slower."
}

@inproceedings{ Sculthorpe:13:ConstrainedMonad,
    author    = "Neil Sculthorpe and Jan Bracker and George Giorgidze and Andy Gill",
    title     = "The Constrained-Monad Problem",
    booktitle = "Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming",
    publisher = "ACM",
    location  = "Boston, Massachusetts",
    url       = "http://dl.acm.org/citation.cfm?doid=2500365.2500602",
    pages     = "287--298",
    year      = 2013,
    xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Sculthorpe-13-ConstrainedMonad.pdf},
    abstract  =  "In Haskell, there are many data types that would form
                  monads were it not for the presence of type-class
                  constraints on the operations on that data type.
                  This is a frustrating problem in practice, because
                  there is a considerable amount of support and
                  infrastructure for monads that these data types
                  cannot use.  Using several examples, we show that a
                  monadic computation can be restructured into a
                  normal form such that the standard monad class
                  can be used.  The technique is not specific
                  to monads, and we show how it can also be applied to
                  other structures, such as applicative functors.  One
                  significant use case for this technique is domain-specific
                  languages, where it is often desirable to
                  compile a deep embedding of a computation to some
                  other language, which requires restricting the types
                  that can appear in that computation."
}

@article{ Sculthorpe:14:WorkIt,
    author       = "Neil Sculthorpe and Graham Hutton",
    title        = "Work It, Wrap It, Fix It, Fold It",
    journal      = "Journal of Functional Programming",
    pages        = "113--127",
    volume       = 24,
    number       = 1,
    publisher    = "Cambridge University Press",
    year         = 2014,
    url          = "http://dx.doi.org/10.1017/S0956796814000045",
    xurl         = "http://www.ittc.ku.edu/csdl/fpg/files/Sculthorpe-14-WorkIt.pdf",
   abstract      = "The worker/wrapper transformation is a general-purpose technique
                    for refactoring recursive programs to improve their performance.
                    The two previous approaches to formalising the technique were
                    based upon different recursion operators and different correctness
                    conditions.  In this article we show how these two approaches can
                    be generalised in a uniform manner by combining their correctness
                    conditions, how the theory can be extended with new conditions
                    that are necessary (in addition to sufficient) to ensure the correctness
                    of the worker/wrapper technique, and explore the benefits that result.
                    All the proofs have been mechanically verified using the Agda system."
}

@article{Gill:13:TypesKansasLava,
   issn={1388-3690},
   journal={Journal of Higher-Order and Symbolic Computation},
   doi={10.1007/s10990-013-9098-7},
   url={http://dx.doi.org/10.1007/s10990-013-9098-7},
   xurl = "http://www.ittc.ku.edu/csdl/fpg/files/Gill-13-TypesKansasLava.pdf",
   publisher={Springer US},
   keywords={Domain specific languages; Hardware; Synthesis; Types},
   pages={1-20},
   title={Types and Associated Type Families for Hardware Simulation and Synthesis:
          The Internals and Externals of {K}ansas {L}ava},
   author="Andy Gill and Tristan Bull and Andrew Farmer and Garrin Kimmell and Ed Komp",
   year = 2013,
   abstract={In this article
we overview the design and implementation of the second generation
of Kansas Lava.
Driven by the needs and experiences
of implementing telemetry decoders and other circuits,
we have made a number of improvements to both the external API
and the internal representations used.
We have retained our dual shallow/deep
representation of signals in general, but now have a number of externally visible
abstractions for combinatorial and sequential circuits, and enabled signals.
We introduce these abstractions, as well as our abstractions for
reading and writing memory.
Internally, we found the need to represent unknown values inside our circuits,
so we made aggressive use of associated type families to lift our values in a principled
and regular way. We discuss this design decision, how it unfortunately
complicates the internals of Kansas Lava, and how
we mitigate this complexity.
Finally, when connecting Kansas Lava to the real world,
the standardized idiom of using named input and output ports
is provided by Kansas Lava using a new monad, called \verb|Fabric|.
We present the design of this Fabric monad, and
illustrate its use in a small but complete example.}
}


@inproceedings{Sculthorpe:13:HERMITinTree,
    author       = "Neil Sculthorpe and Andrew Farmer and Andy Gill",
    title        = "The {HERMIT} in the Tree: Mechanizing Program Transformations in the {GHC} Core Language",
    booktitle    = "Proceedings of the 24th Symposium on Implementation and Application of Functional Languages",
    location     = "Oxford, England",
    series       = "Lecture Notes in Computer Science",
    pages        = "86--103",
    volume       = "8241",
    year         = 2013,
    url          = "http://dx.doi.org/10.1007/978-3-642-41582-1_6",
    xurl         = "http://www.ittc.ku.edu/csdl/fpg/files/Sculthorpe-13-HERMITinTree-extended.pdf",
    abstract     = "This paper describes our experience using the HERMIT toolkit to apply
well-known transformations to the internal core language of the
Glasgow Haskell Compiler.  HERMIT provides several mechanisms to
support writing general-purpose transformations: a domain-specific
language for strategic programming specialized to GHC's core
language, a library of primitive rewrites, and a shell-style--based
scripting language for interactive and batch usage.

There are many program transformation techniques that have been
described in the literature but have not been mechanized and made
available inside GHC --- either because they are too specialized to
include in a general-purpose compiler, or because the developers'
interest is in theory rather than implementation. The mechanization
process can often reveal pragmatic obstacles that are glossed over in
pen-and-paper proofs; understanding and removing these obstacles is our
concern. Using HERMIT, we implement eleven examples of three program
transformations, report on our experience, and describe improvements
made in the process."
}


@inproceedings{Farmer:12:HERMITinMachine,
   author        = "Andrew Farmer and Andy Gill and Ed Komp and Neil Sculthorpe",
   title         = "The {HERMIT} in the Machine: A Plugin for the Interactive Transformation of {GHC} Core Language Programs",
   booktitle     = "Proceedings of the ACM SIGPLAN Haskell Symposium",
   series        = "Haskell '12",
   year          = 2012,
   isbn          = "978-1-4503-1574-6",
   location      = "Copenhagen, Denmark",
   pages         = "1--12",
   url           = "http://doi.acm.org/10.1145/2364506.2364508",
   xurl          = "http://www.ittc.ku.edu/csdl/fpg/files/Farmer-12-HERMITinMachine.pdf",
   doi           = "10.1145/2364506.2364508",
   acmid         = 2364508,
   publisher     = "ACM",
   keywords      = "{DSL}s, equational reasoning, {GHC}, optimization, strategic programming",
   abstract      = "The importance of reasoning about and refactoring programs
is a central tenet of functional programming.
Yet our compilers and development toolchains
only provide rudimentary support for these tasks.
This paper introduces
a programmatic and compiler-centric interface
that facilitates refactoring and equational reasoning.
To develop our ideas, we have implemented HERMIT, a toolkit enabling
informal but systematic transformation of Haskell
programs from \emph{inside} the Glasgow Haskell Compiler{\textquoteright}s
optimization pipeline.
With HERMIT, users can experiment with optimizations
and equational reasoning, while the
tedious heavy lifting of performing the actual transformations
is done for them.

HERMIT provides a transformation API that can be
used to build higher-level rewrite tools.
One use-case is
prototyping new optimizations as clients of this API
before being committed to the GHC toolchain.
We describe a HERMIT application---a
read-eval-print shell for performing transformations using HERMIT.
We also demonstrate using this shell to prototype an optimization
on a specific example, and report our initial experiences and
remaining challenges.",
}

@inproceedings{Farmer:12:WebDSLs,
   author        = "Andrew Farmer and Andy Gill",
   title         = "Haskell {DSL}s for Interactive Web Services",
   booktitle     = "1st International Workshop on Cross-model Language Design and Implementation",
   location      = "Copenhagen, Denmark",
   year          = 2012,
   month         = "Sep",
   url      = "http://www.ittc.ku.edu/csdl/fpg/files/Farmer-12-WebDSLs.pdf",
   xurl     = "http://workshops.inf.ed.ac.uk/xldi2012/",
   abstract      = {Robust cross-platform GUI-based applications are challenging to write in Haskell,
not because providing hooks into existing GUI frameworks is hard,
but because these hooks are both platform dependent and prone to rapid bit-rot.
Browser-based user interfaces implemented using
Javascript and HTML5 offer some relief from this situation,
providing a standardized cross-platform API.
However, Javascript is a client-side scripting language, and
a traditional shallow, foreign-function-call style Haskell
interface to the client does not scale well because calling a
Javascript command involves sending the command, and optionally waiting for a response, over a network.
Instead, we build a deep embedding of Javascript commands inside a Javascript monad.
Along with supporting web-based infrastructure,
we deliver entire program fragments
to our web-based applications.
Using our monad, the Haskell programmer can choose the
granularity of interaction, with the option of
having reactive interfaces that are completely
handled by the client.}
}

@inproceedings{Frisby:12:AlmostHomomorphicFunctions,
	       author = {Nicolas Frisby and Andy Gill and Perry Alexander},
	       title = {A Pattern for Almost Homomorphic Functions},
	       booktitle = {ACM SIGPLAN Workshop on Generic Programming},
	       location = {Copenhagen, Denmark},
	       year = 2012,
	       month = {Sep},
	       abstract = {Strong typing presents the programmer with a trade-off between correctness and
code complexity: more exact types prevent errors but less exact types enable
reuse.
Current functional programming practice prefers general types over exact types
in large programs like compilers because of the reuse. Exact typing in these
programs would require numerous similar data types and conversions between
them.
We factor out a pattern in such conversions as a reusable Haskell function. We
extend existing generic programming techniques to define it and to use it
without introducing undue obfuscation.
Our reusable function eliminates the boilerplate for conversions between the
numerous exact types. It therefore delivers the benefits of exact types and
simulates the reusability of general types with lightweight generic
programming.
We demonstrate our function by using it to define a lambda-lifting function
with an exact range type that has no constructor for lambdas.}
}

@inproceedings {Gill:12:PatchLogic,
   title = {Handshaking in {K}ansas {L}ava using Patch Logic},
   author = {Andy Gill and Bowe Neuenschwander},
   booktitle = {Practical Aspects of Declarative Languages},
   publisher = {Springer-Verlag},
   series= {LNCS},
   volume = 7149,
   location = "Philadelphia, PA",
   year=2012,
   month="January",
   url      = "http://www.ittc.ku.edu/csdl/fpg/files/Gill-12-PatchLogic.pdf",
   abstract = { Designing hardware is like writing music for an
                  orchestra - lots of pieces have to come together at
                  the correct time for everything to work. In systems
                  design, there is a confusing array of standards for
                  allowing cooperating components, and little
                  type-level support in traditional design
                  methodologies for helping connect components with
                  pre-arranged protocols. In this paper, we explore
                  bringing protocol-level types to communicating
                  processes. Inside our hardware description language
                  Kansas Lava we introduce the notation of a patch,
                  which is a communicating component with
                  well-understood protocols. We build a theory round
                  the notion of patches, which we call patch logic,
                  and then use the patch abstraction to build a small
                  driver for an FPGA board. }
}

@proceedings{IFL11,
  title={Implementation and Application of Functional Languages},
  editor={Andy Gill and Jurriaan Hage},
  publisher={Springer, LNCS 7257},
  year=2011,
  month={October}
}

@inproceedings {Gill:11:Declarative,
	       title = {Declarative {FPGA} Circuit Synthesis using {K}ansas {L}ava},
	       booktitle = {The International Conference on Engineering of Reconfigurable Systems and Algorithms},
	       year = 2011,
	       month = {July},
	       location = {Las Vegas, Nevada, USA},
	       author = {Andy Gill},
    url      = "http://www.ittc.ku.edu/csdl/fpg/files/Gill-11-Declarative.pdf",
    abstract={Designing and debugging hardware components is
                  challenging, especially when performance
                  requirements demands a complex orchestra of
                  cooperating and highly synchronized computation
                  engines. New language-based solutions to this problem
                  have the potential to revolutionize how we think
                  about and build circuits. In this paper, we describe
                  our language- based approach to semi-formal
                  co-design. Using examples, we will show how
                  generative techniques, high-level interfaces, and
                  refinement techniques like the worker/wrapper
                  transformation can be used to take descriptions of
                  specialized computation, and generate efficient
                  circuits. Kansas Lava, our high-level hardware
                  description language built on top of the functional
                  language Haskell, acts as a bridge between these
                  computational descriptions and synthesizable
                  VHDL. Central to the whole approach is the use of
                  Haskell types to express communication and timing
                  choices between computational components. Design
                  choices and engineering compromises during co-design
                  become type-centric refinements, encouraging
                  architectural exploration. }
}

@inproceedings{Gill:11:DerivingLDPC,
 author = {Gill, Andy and Farmer, Andrew},
 title = {Deriving an Efficient {FPGA} Implementation of a Low Density Parity Check Forward Error Corrector},
 booktitle = {Proceedings of the 16th ACM SIGPLAN international conference on Functional programming},
 series = {ICFP '11},
 year = 2011,
 isbn = {978-1-4503-0865-6},
 location = {Tokyo, Japan},
 pages = {209--220},
 numpages = 12,
 url = {http://doi.acm.org/10.1145/2034773.2034804},
 doi = {10.1145/2034773.2034804},
 acmid = 2034804,
 publisher = {ACM},
 keywords = {dsl, error correction, lava, ldpc},
 month = {Sep},
 location = {Tokyo, Japan},
 abstract={Creating correct hardware is hard. Though there is much
                  talk of using formal and semi-formal methods to
                  develop designs and implementations, in practice
                  most implementations are written without the support
                  of any formal or semi-formal methodology. Having
                  such a methodology brings many benefits, including
                  improved likelihood of a correct implementation,
                  lowering the cost of design exploration and lowering
                  the cost of certification. In this paper, we
                  introduce a semi formal methodology for connecting
                  executable specifications written in the functional
                  language Haskell to efficient VHDL
                  implementations. The connection is performed by
                  manual edits, using semi-formal equational reasoning
                  facilitated by the worker/wrapper transformation,
                  and directed using commutable functors. We explain
                  our methodology on a full-scale example, an
                  efficient Low-Density Parity Check forward error
                  correcting code, which has been implemented on a
                  Virtex-5 FPGA.}
}

@inproceedings{Gill:11:GeneratingLDPC,
 author = {Gill, Andy and Bull, Tristan and DePardo, Dan and Farmer, Andrew and Komp, Ed and Perrins, Erik},
 title = {Using Functional Programming to Generate an {LDPC} Forward Error Corrector},
 booktitle = {Proceedings of the IEEE 19th Annual International Symposium on Field-Programmable Custom Computing Machines},
 series = {FCCM '11},
 year = 2011,
 isbn = {978-0-7695-4301-7},
 pages = {133--140},
 numpages = 8,
 url = {http://dx.doi.org/10.1109/FCCM.2011.31},
 doi = {10.1109/FCCM.2011.31},
 acmid = 1990171,
 publisher = {IEEE Computer Society},
 month={May},
 location = {Salt Lake City, UT, USA},
}

@mastersthesis{Bull:11:FECandFP,
   author   = {Tristan Bull},
   title    = {Forward Error Correction and Functional Programming},
   school   = {The University of Kansas},
   year     = 2011,
   url      = {http://www.ittc.ku.edu/csdl/fpg/files/Bull-11-FECandFP.pdf},
   abstract = {This thesis contains a collection of work I have
                  performed while working on Dr. Erik Perrins’
                  Efficient Hardware Implementation of Iterative FEC
                  Decoders project. The following topics and my
                  contributions to those topics are included in this
                  thesis. The first topic is a Viterbi decoder
                  implemented in the Haskell programming
                  language. Next, I will briefly introduce Kansas
                  Lava, a Haskell DSL developed by my advisor,
                  Dr. Andy Gill, and other students and staff. The
                  goal of Kansas Lava is to generate efficient
                  synthesizable VHDL for complex circuits. I will
                  discuss one such circuit, a large-scale LDPC decoder
                  implemented in Kansas Lava that has been synthesized
                  and tested on FPGA hardware. After discussing the
                  synthesis and simulation results of the decoder
                  circuit, I will discuss a memory interface that was
                  developed for use in our HFEC system. Finally, I tie
                  these individual projects together in a discussion
                  on the benefits of functional programming in
                  hardware design.}
}

@techreport{Gill:11:CatchingSat,
	title = {Capturing Functions and Catching Satellites},
	note = {ITTC Technical Report ITTC-FY2011-TR-29952011-1},
	year = 2011,
	month = {January},
        xurl  = "http://www.ittc.ku.edu/csdl/fpg/files/Gill-11-CatchingSat.pdf",
	abstract = {The 2009 ICFP programming contest problem required contestants to control
virtual satellites that obey basic physical laws.  The orbital physics
behavior of the system was simulated via a binary provided to contestants
which ran on top of a simple virtual machine.  Contestants were required to
implement the virtual machine along with a controller program to manipulate
the satellite{\textquoteright}s behavior. In this paper, we describe the modeling of the
simulation environment, with a focus on the compilation and testing
infrastructure for the generated binaries for this virtual machine. This
infrastructure makes novel use of an implementation of a deeply embedded
Domain Specific Language (DSL) within Haskell.  In particular, with use of
IO-based observable sharing, it was straightforward for a function to be both
an executable specification as well as a portable implementation,
and because of this the rendered binary was found to be robust and reliable.},
	author = {Andy Gill and Garrin Kimmell}
}


@article{Hutton:10:F5,
	author = "Graham Hutton and Mauro Jaskelioff and Andy Gill",
        title  = "Factorising Folds for Faster Functions",
 xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Hutton-10-F5.pdf},
 xxurl = {http://www.ittc.ku.edu/csdl/fpg/files/Hutton-10-F5-extended.pdf},
        abstract ={The worker/wrapper transformation is a general technique for improving the performance of
        recursive programs by changing their types. The previous formalisation (Gill & Hutton, 2009) was
based upon a simple fixed point semantics of recursion. In this article we develop a more structured
approach, based upon initial algebra semantics. In particular, we show how the worker/wrapper
transformation can be applied to programs defined using the structured pattern of recursion captured
by fold operators, and illustrate our new technique with a number of examples.},
 journal = "Journal of Functional Programming",
 publisher = "Cambridge University Press",
 volume = 20,
 number = "3-4",
 pages = "353--373",
 year = 2010,
}

@inproceedings{Matlage:10:BeginningMiddleEnd,
   title="Every Animation Should Have a Beginning, a Middle, and an End",
   author="Kevin Matlage and Andy Gill",
   booktitle = "Post-Proceedings of Trends in Functional Programming",
   month="May",
   year=2010,
   xurl      = "http://www.ittc.ku.edu/csdl/fpg/files/Matlage-10-BeginningMiddleEnd.pdf",
   publisher = {Springer-Verlag},
   series= {LNCS},
   volume = 6546,
   abstract = {Animations are sequences of still images chained
                  together to tell a story. Every story should have a
                  beginning, a middle, and an end. We argue that this
                  advice leads to a simple and useful idiom for
                  creating an animation Domain Specific Language
                  (DSL). We introduce our animation DSL, and show how
                  it captures the concept of beginning, middle, and
                  end inside a Haskell applicative functor we call
                  Active. We have an implementation of our DSL inside
                  the image generation accelerator, ChalkBoard, and we
                  use our DSL on an extended example, animating a
                  visual demonstration of the Pythagorean Theorem.}
}

@inproceedings{Gill:10:TypesKansasLava,
   title="Types and Type Families for Hardware Simulation and Synthesis: The Internals and Externals of {K}ansas {L}ava",
   author="Andy Gill and Tristan Bull and Andrew Farmer and Garrin Kimmell and Ed Komp",
   booktitle = "Post-Proceedings of Trends in Functional Programming",
   month="May",
   year=2010,
   publisher = {Springer-Verlag},
   series= {LNCS},
   volume = 6546,
	abstract = {In this paper,

we overview the design and implementation of our latest
version of Kansas Lava. Driven by needs and experiences
of implementing telemetry circuits,
we have made a number of recent improvements to both the external API
and the internal representations used.
We have retained our dual shallow/deep
representation of signals in general, but now have a number of externally visible
abstractions for combinatorial, sequential, and enabled signals.
We introduce these abstractions, as well as our new abstractions for
memory and memory updates.
Internally, we found the need to represent unknown values inside our circuits,
so we made aggressive use of type families to lift our values in a principled
and regular way. We discuss this design decision, how it unfortunately
complicates the internals of Kansas Lava, and how
we mitigate this complexity.}
}

@inproceedings{Farmer:10:WhatsTheMatter,
   title="What's the matter with {K}ansas {L}ava?",
   author="Andrew Farmer and Garrin Kimmell and Andy Gill",
   booktitle = "Post-Proceedings of Trends in Functional Programming",
   month="May",
   publisher = {Springer-Verlag, LNCS 6546},
   year=2010,
	abstract = {Kansas Lava is a functional hardware description language implemented
in Haskell. In the course of attempting to generate ever larger circuits,
we have found the need to effectively test and debug the internals of
Kansas Lava. This includes confirming both the simulated behavior of the
circuit and its hardware realization via generated VHDL. In
this paper we share our approach to this problem, and discuss
the results of these efforts.
}
}

@inproceedings {Gill:10:ImprovingVideo,
	title = {Improving the Presentation of Technical Material in Video Talks using Post Production},
	booktitle = {2010 Midwest Section Conference of the American Society for Engineering Education},
	year = 2010,
	month = {September},
	abstract = {In this paper, we present our experiences using our image processing toolkit
ChalkBoard and other video processing tools to post-process a pre-recorded
conference talk. With inexpensive video cameras, video services like youtube.com
and vimeo.com, and widely available and inexpensive video editing software, we
expect this new media to be increasingly used as a mechanism to both promote
research agendas and deliver technical content. In order to explore the use of
such media in more detail, the Functional Programming group at KU recorded a
technical talk and experimented with various post-processing tricks to enhance
the value of the talk. Specifically, we fixed a common lensing issue in software,
added small animations and pictures which matched the gestures of the actors,
improved the visual quality of the slides being talked to,
and experimented with a post-hoc zoom. Overall, the post-processing
stage took considerably longer than anticipated, but did add perceivable
value and impact to the final video.
},
	url = {http://www.ittc.ku.edu/csdl/fpg/files/Gill-10-ImprovingVideo.pdf},
	author = {Andy Gill and Garrin Kimmell and Kevin Matlage},
      what      = {Minor}
}



@inproceedings{Matlage:09:ChalkBoard,
        author="Kevin Matlage and Andy Gill",
        title="Chalk{B}oard: {M}apping Functions to Polygons",
        booktitle = "Proceedings of the Symposium on Implementation and Application of Functional Languages",
        publisher = {Springer-Verlag},
        series= {LNCS},
        volume = 6041,
        xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Matlage-09-ChalkBoard.pdf},
        abstract={ChalkBoard is a domain specific language for describing images.
                The ChalkBoard language is uncompromisingly functional
                and encourages the use of modern functional idioms.
                ChalkBoard uses off-the-shelf
                graphics cards to speed up rendering of functional descriptions.
                In this paper, we
                describe the design of the core ChalkBoard language,
                and the architecture of our static image generation accelerator.},
        month={Sep},
        year      = 2009
}

@inproceedings{Gill:09:KansasLava,
        author="Andy Gill and Tristan Bull and Garrin Kimmell and Erik Perrins and Ed Komp and Brett Werling",
        title="Introducing {K}ansas {L}ava",
        booktitle = "Proceedings of the Symposium on Implementation and Application of Functional Languages",
        publisher = {Springer-Verlag},
        series= {LNCS},
        volume = 6041,
        xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Gill-09-KansasLava.pdf},
        abstract={Kansas Lava is a domain specific language for hardware description.
                Though there have been a number of previous implementations of Lava,
                we have found the design space rich, with unexplored choices.
                We use a direct (Chalmers style)
                specification of circuits, and make significant use of Haskell
                overloading of standard classes, leading to concise circuit
                descriptions.
                Kansas Lava supports both simulation (inside GHCi),
                and execution via VHDL, by having a dual shallow and deep embedding
                inside our Signal type.
                We also have a lightweight sized-type mechanism,
                allowing for MATLAB style matrix based specifications to be directly
                expressed in Kansas Lava.},
        month={Sep},
        year      = 2009
}

@inproceedings{Werling:09:ITC,
	author	= "B. Werling and E. Perrins and A. Gill",
	title   = {Implementation of an {LDPC} decoder using Functional Programming Languages},
      booktitle = {Proceedings of the International Telemetering Conference},
      location  = "Las Vegas, NV",
      year      = 2009,
      month     = {Oct},
      note      = "(Student Paper)",
      what      = {Other},
}

@inproceedings{Bull:09:ITC,
	author	= "T. Bull and E. Perrins and A. Gill",
	title   = {Implementation of the Viterbi Algorithm using Functional Programming Languages},
      booktitle = {Proceedings of the International Telemetering Conference},
      location  = "Las Vegas, NV",
      year      = 2009,
      month     = {Oct},
      note      = "(Student Paper)",
      what      = {Other},
}

@inproceedings{Gill:09:TypeSafeReification,
    author      = {Andy Gill},
    title       = {Type-Safe Observable Sharing in {H}askell},
    booktitle   = {Proceedings of the Second {ACM} {SIGPLAN} {H}askell Symposium},
    year        = 2009,
    month       = {Sep},
    series = {Haskell '09},
    isbn = {978-1-60558-508-6},
    location = {Edinburgh, Scotland},
    pages = {117--128},
    url = {http://doi.acm.org/10.1145/1596638.1596653},
    xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Gill-09-TypeSafeReification.pdf},
    doi = {10.1145/1596638.1596653},
    acmid = {1596653},
    publisher = {ACM},
    address = {New York, NY, USA},
    keywords = {DSL compilation, observable sharing},
    abstract    = {Haskell is a great language for writing and supporting
embedded Domain Specific Languages (DSLs).
Some form of observable sharing
is often a critical capability for allowing so-called deep DSLs
to be compiled and processed. In this paper,
we describe and explore uses of an IO function
for reification which allows direct observation of sharing.},
}

@inproceedings{Gill:2009:KUREDSL,
 author = {Gill, Andy},
 title = {A {H}askell Hosted {DSL} for Writing Transformation Systems},
 booktitle = {Proceedings of the IFIP TC 2 Working Conference on Domain-Specific Languages},
 series = {DSL '09},
 year = 2009,
 month = {July},
 isbn = {978-3-642-03033-8},
 location = {Oxford, UK},
 pages = {285--309},
 numpages = 25,
 url = {http://dx.doi.org/10.1007/978-3-642-03034-5_14},
 xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Gill-09-KUREDSL.pdf},
 doi = {10.1007/978-3-642-03034-5_14},
 acmid = 1575968,
 publisher = {Springer-Verlag},
 abstract = { KURE is a Haskell hosted Domain Specific Language (DSL)
                  for writing transformation systems based on rewrite
                  strategies.  When writing transformation systems, a
                  significant amount of engineering effort goes into
                  setting up plumbing to make sure that specific
                  rewrite rules can fire.  Systems like Stratego and
                  Strafunski provide most of this plumbing as
                  infrastructure, allowing the DSL user to focus on
                  the rewrites rules.  KURE is a strongly typed
                  strategy control language in the tradition of
                  Stratego and Strafunski.  It is intended for writing
                  reasonably efficient rewrite systems, makes use of
                  type families to provide a delimited generic
                  mechanism for tree rewriting, and provides support
                  for efficient identity rewrite detection. },
}

@TechReport{Kimmell:09:ICFPContestProblem,
author	= "Garrin Kimmell and Kevin Matlage and
	Tristan Bull and Nicolas Frisby and Andy Gill and
	Michael Jantz and Ed Komp and Megan Peck and
	Wesley Peck and  Mark Snyder and Brett Werling",
title	= "The 2009 {ICFP} Programming Contest Problem Specification",
month	= "June",
year	= 2009,
institution	= "Information Telecommunication and Technology Center, University of Kansas, Lawrence, KS",
   xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Kimmell-09-ICFPContestProblem.pdf}
}


@proceedings{PADL09,
  title={Practical Aspects of Declarative Languages},
  editor={Andy Gill and Terrance Swift},
  publisher={Springer, LNCS 5418},
  year=2009,
  month={January}
}

@article{Gill:09:WW,
 author = {Andy Gill and Graham Hutton},
 title = {The worker/wrapper transformation},
 xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Gill-09-WW.pdf},
 xxurl = {http://www.ittc.ku.edu/csdl/fpg/files/Gill-09-WW-extended.pdf},
 abstract = {The worker/wrapper transformation is a technique for changing the type
of a computation, usually with the aim of improving its performance.
It has been used by compiler writers for many years, but the technique
is little-known in the wider functional programming community, and has
never been described precisely.  In this article we explain, formalise,
and explore the generality of the worker/wrapper transformation. We
also provide a systematic recipe for its use as an equational reasoning
technique for improving the performance of programs, and illustrate the
power of this recipe using a range of examples.
},
 journal = "Journal of Functional Programming",
        publisher = "Cambridge University Press",
        volume = 19,
        number = 2,
        pages = "227--251",
        month = {March},
        year = 2009
}


@inproceedings{Nordlander:2008:RecBinds08,
 author = {Nordlander, Johan and Carlsson, Magnus and Gill, Andy J.},
 title = {Unrestricted pure call-by-value recursion},
 booktitle = {Proceedings of the 2008 ACM SIGPLAN workshop on ML},
 series = {ML '08},
 year = 2008,
 isbn = {978-1-60558-062-3},
 location = {Victoria, BC, Canada},
 pages = {23--34},
 numpages = 12,
 url = {http://doi.acm.org/10.1145/1411304.1411309},
 doi = {10.1145/1411304.1411309},
 acmid = 1411309,
 publisher = {ACM},
 abstract = {Call-by-value languages commonly restrict recursive
             definitions by only allowing functions and syntactically
             explicit values in the right-hand sides. As a
             consequence, some very appealing programming patterns
             that work well in lazy functional languages are hard to
             apply in a call-by-value setting, even though they might
             not be using laziness for any other purpose than to
             enable the desired form of recursion.

             In this paper we present an operational semantics as well
             as a straightforward implementation technique for
             unrestricted recursion under pure call-by-value.  On that
             basis we are able to demonstrate that highly recursive
             programming idioms such as combinator-based parsing are
             indeed compatible with call-by-value evaluation.},
 keywords = {call-by-value, combinator libraries, implementation, semantics, value recursion},
}

@inproceedings{Harrison:08:Asynchronous,
 author = {William L. Harrison and Gerard Allwein and Andy Gill and Adam Procter},
 title = {Asynchronous Exceptions as an Effect},
 booktitle = "Ninth International Conference on Mathematics of Program Construction",
 year = 2008,
 month = "July",
 publisher = "Springer-Verlag",
  xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Harrison-08-Asynchronous.pdf},
 abstract = {Asynchronous interrupts abound in computing systems, yet
             they remain a thorny concept for both programming and
             verification practice.  The ubiquity of interrupts
             underscores the importance of developing programming
             models to aid the development and verification of
             interrupt-driven programs.  The research reported here
             recognizes asynchronous interrupts as a computational
             effect and encapsulates them as a building block in
             modular monadic semantics.  The resulting integrated
             semantic model can serve as both a guide for functional
             programming with interrupts and as a formal basis for
             reasoning about interrupt-driven computation as well.},
}


@inproceedings{Gill:07:Hpc,
    author      = {Andy Gill and Colin Runciman},
    title       = {Haskell {P}rogram {C}overage},
    booktitle   = {Proceedings of the 2007 {ACM} {SIGPLAN} {W}orkshop on Haskell},
    year        = 2007,
    month       = {September},
    publisher   = {ACM Press},
  xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Gill-07-Hpc.pdf},
    abstract    = {We describe the design, implementation and use of HPC,
        a tool-kit to record and display Haskell Program Coverage. HPC includes tools that
        instrument Haskell programs to record program coverage, run instrumented
        programs, and display information derived from coverage data in various ways.},
}

@inproceedings{Marlow:07:GhciDebugger,
    author      = {Simon Marlow and Jos\'{e} Iborra and Bernard Pope and Andy Gill},
    title       = {A lightweight interactive debugger for {H}askell},
    booktitle   = {Proceedings of the 2007 {ACM} {SIGPLAN} {W}orkshop on Haskell},
    year        = 2007,
    month       = {September},
    publisher   = {ACM Press},
    xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Marlow-07-GhciDebugger.pdf},
    abstract    = {This paper describes the design and construction of a Haskell
        source-level debugger built into the GHCi interactive environment.  We
        have taken a pragmatic approach: the debugger is based on the
        traditional stop-examine-continue model of online debugging, which is
        simple and intuitive, but has traditionally been shunned in the
        context of Haskell because it exposes the lazy evaluation order.  We
        argue that this drawback is not as severe as it may seem, and in some
        cases is an advantage.

        The design focuses on availability: our debugger is intended
        to work on all programs that can be compiled with GHC, and without
        requiring the programmer to jump through additional hoops to debug
        their program.  The debugger has a novel approach for reconstructing
        the type of runtime values in a polymorphic context.  Our
        implementation is light on complexity, and was integrated into GHC
        without significant upheaval.},
}

@inproceedings{Gill:06:IntroHERA,
  author    = {Andy Gill},
  title     = {Introducing the {H}askell {E}quational {R}easoning {A}ssistant},
  booktitle = {Proceedings of the 2006 ACM SIGPLAN {W}orkshop on Haskell},
  year      = 2006,
  pages     = {108--109},
  isbn      = {1-59593-489-8},
  location  = {Portland, Oregon, USA},
  publisher = {ACM Press},
  xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Gill-06-IntroHERA.pdf},
  abstract  = {We introduce the new, improved version of the
        Haskell Equational Reasoning Assistant, which consists
        of an Ajax application for rewriting Haskell fragments
        in their context, and an API for scripting non-trivial rewrites.}
}

@inproceedings{Moran:01:Legacy,
  author        = {Andrew Moran and Jim Teisher and Andrew Gill and Emir Pasalic and John Veneruso},
  title         = {Automated translation of legacy code for {ATE}},
  booktitle     = {Proceedings of the IEEE International Test Conference},
  year          = 2001,
  isbn          = {0-7803-7169-0},
  pages         = {148--156},
  publisher     = {IEEE Computer Society},
  xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Moran-01-Legacy.pdf},
  abstract      = {When an Automated Testing Equipment (ATE) company
          designs a new system, the issue of backward compatibility is
          always a major concern, both for the company and its
          customers. If backward compatibility is maintained, the ATE
          application engineers face the difficult task of trying to
          support new features on an aging system. The alternative is
          to face the problem of converting old test programs to the
          new environment. Translation of legacy code involves an
          automatic translation tool, and some application effort
          applied to those problems the translator couldn't
          resolve. To minimize the amount of work required from the
          application engineers, the tool needs to be
          semantically aware; that is, the tool must contain
          domain specific knowledge and use that knowledge when
          translating. The more knowledge a tool has at its disposal,
          the less code an application engineer is forced to translate
          by hand.

          Until recently, it has been difficult to perform automatic
          translation satisfactorily because it was not cost effective
          to write a translator that possessed such semantic
          understanding of the test programs. By making good use of
          Functional Programming techniques and tools, we were able to
          construct a cost effective, semantically aware translation
          tool in a fraction of the time needed by traditional
          methods. Based upon its performance during testing, we
          believe the tool to correctly translate the majority of
          test programs, thereby greatly easing the applications
          engineers' burden.},
}

@inproceedings{Gill:00:HOOD,
  author        = "Andy Gill",
  title         = "Debugging {H}askell by observing intermediate data structures",
  booktitle     = "Proceedings of the 2000 ACM SIGPLAN {W}orkshop on Haskell,
                   Technical report of the University of Nottingham",
  year          = 2000,
  xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Gill-00-HOOD.pdf},
    abstract    = {Haskell has long needed a debugger. Although there has
          been much research into the topic of debugging lazy functional
          programs, no robust tool has yet come from the Haskell community
          that can help debug full Haskell - until now. This paper describes
          a portable debugger for full Haskell, building only on commonly
          implemented extensions. It is based on the concept of observation
          of intermediate data structures, rather than the more traditional
          stepping and variable examination paradigm used by traditional
          imperative debuggers.},
}

@inproceedings{Okasaki:98:IntMap,
  author        = "Chris Okasaki and Andy Gill",
  title         = "Fast mergeable integer maps",
  pages         = {77--86},
  booktitle     = "ACM SIGPLAN Workshop on ML",
  year          = 1998,
  month         = {September},
  xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Okasaki-98-IntMap.pdf},
  abstract      = {Finite maps are ubiquitous in many applications, but
        perhaps nowhere more so than in compilers and other language
        processors. In these applications, three operations on finite
        maps dominate all others: looking up the value associated with
        a key, inserting a new binding, and merging two finite
        maps. Most implementations of finite maps in functional
        languages are based on balanced binary search trees, which
        perform well on the first two, but poorly on the third. We
        describe an implementation of finite maps with integer keys
        that performs well in practice on all three operations. This
        data structure is not new-indeed, it is thirty years old this
        year-but it deserves to be more widely known.}
}


@phdthesis{Gill:96:PhD,
   author   = {Andrew Gill},
   title    = {Cheap deforestation for non-strict functional languages},
   school   = {The University of Glasgow},
   month    = {January},
   year     = 1996,
   xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Gill-96-PhD.pdf},
   abstract = {In functional languages intermediate data structures are
	  often used as ''glue'' to connect separate parts of a program
	  together. Deforestation is the process of automatically removing
	  intermediate data structures. In this thesis we present and analyse a
	  new approach to deforestation. This new approach is both practical and
	  general.

	  We analyse in detail the problem of list removal rather than
	  the more general problem of arbitrary data structure removal. This
	  more limited scope allows a complete evaluation of the pragmatic
	  aspects of using our deforestation technology.

	  We have implemented our list deforestation algorithm in the
	  Glasgow Haskell compiler. Our implementation has allowed
	  practical feedback. One important conclusion is that a new
	  analysis is required to infer function arities and the
	  linearity of lambda abstractions. This analysis renders the
	  basic deforestation algorithm far more effective.

	  We give a detailed assessment of our implementation of
	  deforestation. We measure the effectiveness of our
	  deforestation on a suite of real application programs. We
	  also observe the costs of our deforestation algorithm.}
}

@inproceedings{Gill:95:TechGUIHERA,
   author       = {Andy Gill},
   title        = {The technology behind a graphical user interface for an equational reasoning assistant},
   booktitle    = {Proceedings of the 1995 Glasgow Workshop on Functional Programming,
                   Electronic Workshops in Computing, Ullapool, Scotland},
   year         = 1995,
  xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Gill-95-TechGUIHERA.pdf},
   abstract     = {The Haskell Equational Reasoning Assistant (HERA) is an application
        written in Haskell that helps users construct and present equational
        reasoning style proofs. In this paper we discuss the technology behind
        HERA's graphical user interface.}
}


@inproceedings{Gill:94:CheapDeforestationPrac,
  author        = {Andrew Gill and Simon {Peyton Jones}},
  title         = {Cheap Deforestation in Practice: An Optimizer for {H}askell},
  booktitle     = {IFIP Congress (1)},
  year          = 1994,
  pages         = {581--586},
  xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Gill-94-CheapDeforestationPrac.pdf},
  abstract      = {We present a simple, automatic transformation - the
    foldr/build transformation - which successfully removes many
    intermediate lists from programs written in non-strict functional
    programming languages. While the idea is simple and elegant, it
    turns out that some care is needed in the compiler to set up the
    right conditions for the foldr/build transformation to be
    applicable. We report on this practical experience, and present
    results which quantify the benefits that can in practice be
    achieved.}
}

@inproceedings{Gill:93:ShortCutFusion,
  author       = {Andrew Gill and John Launchbury and Simon {Peyton Jones}},
  title        = {A short cut to deforestation},
  booktitle    = {FPCA '93: Proceedings of the conference on Functional Programming Languages and Computer Architecture},
  year         = 1993,
  isbn         = {0-89791-595-X},
  pages        = {223--232},
  location     = {Copenhagen, Denmark},
  doi          = {http://doi.acm.org/10.1145/165180.165214},
  publisher    = {ACM Press},
  url = {http://dl.acm.org/citation.cfm?doid=165180.165214},
  xurl = {http://www.ittc.ku.edu/csdl/fpg/files/Gill-93-ShortCutFusion.pdf},
  abstract     = {Lists are often used as "glue" to connect separate
  parts of a program together. We propose an automatic technique for
  improving the efficiency of such programs, by removing many of these
  intermediate lists, based on a single, simple, local
  transformation. We have implemented the method in the Glasgow
  Haskell compiler.}
}

@inproceedings{Gill:92:Avoid,
  author       = {John Launchbury and Andrew Gill and John Hughes and Simon Marlow and Simon {Peyton Jones} and Philip Wadler},
  title        = {Avoiding Unnecessary Updates},
  booktitle    = {Glasgow Workshop on Functional Programming, Workshops in Computing},
  pages        = {144-153},
  year         = 1992,
  location     = {Ayr, Scotland},
  publisher    = {Springer-Verlag},
  abstract     = {Graph reduction underlies most implementations of lazy functional
      languages, allowing separate computations to share results when
      sub-terms are evaluated. Once a term is evaluated, the node of the
      graph representing the computation is updated with the value of
      the term. However, in many cases, no other computation requires
      this value, so the update is unnecessary. In this paper we take
      some steps towards an analysis for determining when these updates
      may be omitted.}
}

@inproceedings{Gill:91:NovelPeep,
  author      = {Andrew Gill},
  title       = {A Novel Approach Towards Peephole Optimisations},
  booktitle   = {Proceedings of the 1991 Glasgow Workshop on Functional Programming},
  year        = 1991,
  month       = {August},
  pages       = {100--111},
  editor      = {Rogardt Heldal and
               Carsten Kehler Holst and
               Philip Wadler},
  publisher   = {Springer},
  series      = {Workshops in Computing},
  isbn        = {3-540-19760-5},
  abstract    = {In this paper we examine alternative approaches towards the
    traditional optimisation technique of peepholing. Three simple
    methods of generating quality code are given. The first method
    improves poor juxtapositions while generating code, the second is
    an alternative usage of a solution to the knapsack problem. A
    third hybrid algorithm combines the strong points of both these
    solutions, and is presented as an alternative to conventional
    peepholing.}
}


